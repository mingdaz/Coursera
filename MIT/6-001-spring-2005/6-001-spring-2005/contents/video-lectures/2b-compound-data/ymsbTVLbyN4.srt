1
00:00:00,000 --> 00:00:05,892


2
00:00:05,892 --> 00:00:21,947
[MUSIC PLAYING]

3
00:00:21,947 --> 00:00:23,530
PROFESSOR: Well, so
far in this course

4
00:00:23,530 --> 00:00:26,370
we've been talking
about procedures,

5
00:00:26,370 --> 00:00:29,132
and then just to remind
you of this framework

6
00:00:29,132 --> 00:00:31,090
that we introduced for
talking about languages,

7
00:00:31,090 --> 00:00:33,860
we talked about the
primitive things that

8
00:00:33,860 --> 00:00:36,040
are built into the system.

9
00:00:36,040 --> 00:00:38,947
We mentioned some
means of combination

10
00:00:38,947 --> 00:00:40,530
by which you take
the primitive things

11
00:00:40,530 --> 00:00:42,327
and you make more
complicated things.

12
00:00:42,327 --> 00:00:44,410
And then we talked about
the means of abstraction,

13
00:00:44,410 --> 00:00:46,118
how you can take those
complicated things

14
00:00:46,118 --> 00:00:49,584
and name them so you can use
them as simple building blocks.

15
00:00:49,584 --> 00:00:51,750
And then last time you saw
we went even beyond that.

16
00:00:51,750 --> 00:00:55,570
We saw that by using
higher order procedures,

17
00:00:55,570 --> 00:00:58,400
you can actually express general
methods for computing things.

18
00:00:58,400 --> 00:01:00,150
Like the method
of doing something

19
00:01:00,150 --> 00:01:03,700
by fixed points, or
Newton's method, and so

20
00:01:03,700 --> 00:01:05,420
the incredible
expressive power you

21
00:01:05,420 --> 00:01:08,730
can get just by combining
these means of abstraction.

22
00:01:08,730 --> 00:01:11,400
And the crucial
idea in all of this

23
00:01:11,400 --> 00:01:15,210
is the one that we
build a layered system.

24
00:01:15,210 --> 00:01:17,570
So for instance, if we're
writing the square root

25
00:01:17,570 --> 00:01:23,080
procedure, somewhere the
square root procedure

26
00:01:23,080 --> 00:01:31,490
uses a procedure
called good-enough,

27
00:01:31,490 --> 00:01:35,220
and between those there is some
sort of abstraction boundary.

28
00:01:35,220 --> 00:01:38,060


29
00:01:38,060 --> 00:01:41,450
It's almost as if we go out
and in writing square root,

30
00:01:41,450 --> 00:01:45,120
we go and make a
contract with George,

31
00:01:45,120 --> 00:01:49,060
and tell George that his
job is to write good-enough,

32
00:01:49,060 --> 00:01:50,660
and so long as
good-enough works,

33
00:01:50,660 --> 00:01:52,589
we don't care what it does.

34
00:01:52,589 --> 00:01:54,380
We don't care exactly
how it's implemented.

35
00:01:54,380 --> 00:01:56,770
There are levels of
detail here that are

36
00:01:56,770 --> 00:02:00,450
George's concern and not ours.

37
00:02:00,450 --> 00:02:04,350
So for instance, George might
use an absolute value procedure

38
00:02:04,350 --> 00:02:07,820
that's written by Harry, and
we don't much care about that

39
00:02:07,820 --> 00:02:10,065
or even know that,
maybe, Harry exists.

40
00:02:10,065 --> 00:02:13,830


41
00:02:13,830 --> 00:02:16,760
So the crucial idea is that
when we're building things,

42
00:02:16,760 --> 00:02:21,530
we divorce the task
of building things

43
00:02:21,530 --> 00:02:23,850
from the task of
implementing the parts.

44
00:02:23,850 --> 00:02:27,690


45
00:02:27,690 --> 00:02:29,090
And in a large
system, of course,

46
00:02:29,090 --> 00:02:32,210
we have abstraction barriers
like this at lots, and lots,

47
00:02:32,210 --> 00:02:34,180
and lots of levels.

48
00:02:34,180 --> 00:02:36,960
And that's the idea that we've
been using so far over and over

49
00:02:36,960 --> 00:02:38,290
in implementing procedures.

50
00:02:38,290 --> 00:02:41,080
Well, now what we're
going to do is look

51
00:02:41,080 --> 00:02:44,101
at the same issues for data.

52
00:02:44,101 --> 00:02:46,350
We're going to see that the
system has primitive data.

53
00:02:46,350 --> 00:02:47,724
In fact, we've
already seen that.

54
00:02:47,724 --> 00:02:49,750
We've talked about
numbers as primitive data.

55
00:02:49,750 --> 00:02:52,000
And then we're going to see
their means of combination

56
00:02:52,000 --> 00:02:52,499
for data.

57
00:02:52,499 --> 00:02:55,940
There's glue that allows you
to put primitive data together

58
00:02:55,940 --> 00:02:59,500
to make more complicated,
kind of compound data.

59
00:02:59,500 --> 00:03:04,840
And then we're going to see
a methodology for abstraction

60
00:03:04,840 --> 00:03:07,600
that's a very good thing to use
when you start building up data

61
00:03:07,600 --> 00:03:09,090
in terms of simpler data.

62
00:03:09,090 --> 00:03:11,260
And again, the key
idea is that you're

63
00:03:11,260 --> 00:03:13,770
going to build the
system in layers

64
00:03:13,770 --> 00:03:15,700
and set up abstraction
barriers that

65
00:03:15,700 --> 00:03:19,506
isolate the details
at the lower layers

66
00:03:19,506 --> 00:03:21,630
from the thing that's going
on at the upper layers.

67
00:03:21,630 --> 00:03:25,260
The details at the lower layers,
the ideas, they won't matter.

68
00:03:25,260 --> 00:03:26,850
They're going to
be George's concern

69
00:03:26,850 --> 00:03:29,170
because he signed this
contract with us for how

70
00:03:29,170 --> 00:03:32,030
the stuff that he
implements behaves,

71
00:03:32,030 --> 00:03:36,182
and how he implements
the thing is his problem.

72
00:03:36,182 --> 00:03:37,890
All right, well let's
look at an example.

73
00:03:37,890 --> 00:03:39,890
And the example I'm
going to talk about

74
00:03:39,890 --> 00:03:43,010
is a system that does
arithmetic on rational numbers.

75
00:03:43,010 --> 00:03:46,160
And what I have in mind is
that we should have something

76
00:03:46,160 --> 00:03:51,870
in the computer that
allows us to ask it, like,

77
00:03:51,870 --> 00:03:56,880
what's the sum of 1/2 and
1/4, and somehow the system

78
00:03:56,880 --> 00:04:02,890
should say, yeah, that's 3/4.

79
00:04:02,890 --> 00:04:11,070
Or we should be able to
say what's 3/4 times 2/3,

80
00:04:11,070 --> 00:04:13,650
and the system should be able
to say, yeah, that's 1/2.

81
00:04:13,650 --> 00:04:16,230


82
00:04:16,230 --> 00:04:16,730
Right?

83
00:04:16,730 --> 00:04:18,104
And you know what
I have in mind.

84
00:04:18,104 --> 00:04:20,459
And you also know how to
do this from, I don't know,

85
00:04:20,459 --> 00:04:22,410
fifth grade or sixth grade.

86
00:04:22,410 --> 00:04:23,910
There are these
formulas that say

87
00:04:23,910 --> 00:04:28,530
if I have some fraction which is
a numerator over a denominator,

88
00:04:28,530 --> 00:04:31,940
and I want to add that to
some other fraction which

89
00:04:31,940 --> 00:04:35,470
is another numerator
over another denominator,

90
00:04:35,470 --> 00:04:39,810
then the answer is the
numerator of the first times

91
00:04:39,810 --> 00:04:43,710
the denominator of the
second, plus the numerator

92
00:04:43,710 --> 00:04:48,130
of the second times the
denominator of the first.

93
00:04:48,130 --> 00:04:49,840
That's the numerator
of the answer,

94
00:04:49,840 --> 00:04:52,090
and the denominator
is the product

95
00:04:52,090 --> 00:04:53,260
of the two denominators.

96
00:04:53,260 --> 00:04:53,760
Right?

97
00:04:53,760 --> 00:04:56,850
So there's something from
fifth or sixth grade fraction

98
00:04:56,850 --> 00:04:57,570
arithmetic.

99
00:04:57,570 --> 00:04:59,950
And then similarly, if I
want to multiply two things,

100
00:04:59,950 --> 00:05:05,890
n1 over d1 multiplied
by n2 over d2

101
00:05:05,890 --> 00:05:09,677
is the product of the
numerators over the product

102
00:05:09,677 --> 00:05:10,510
of the denominators.

103
00:05:10,510 --> 00:05:14,330


104
00:05:14,330 --> 00:05:17,960
So it's no problem at all,
but it's absolutely no problem

105
00:05:17,960 --> 00:05:20,520
to think about what
computation you

106
00:05:20,520 --> 00:05:23,760
want to make in adding and
multiplying these fractions.

107
00:05:23,760 --> 00:05:25,880
But as soon as we
go to implement it,

108
00:05:25,880 --> 00:05:27,920
we run up across something.

109
00:05:27,920 --> 00:05:33,320
We don't have what a
rational number is.

110
00:05:33,320 --> 00:05:36,840
So we said that the system
gives us individual numbers,

111
00:05:36,840 --> 00:05:42,110
so we can have 5 and
3, but somehow we

112
00:05:42,110 --> 00:05:44,140
don't have a way
of saying there's

113
00:05:44,140 --> 00:05:49,850
a thing that has both a 3 and
a 4 in it, or both a 2 and a 3.

114
00:05:49,850 --> 00:05:54,980
It's almost as if we'd like
to imagine that somehow there

115
00:05:54,980 --> 00:05:59,010
are these clouds,
and a cloud somehow

116
00:05:59,010 --> 00:06:02,274
has both a numerator
and a denominator in it,

117
00:06:02,274 --> 00:06:04,190
and that's what we'd
like to work in terms of.

118
00:06:04,190 --> 00:06:06,445


119
00:06:06,445 --> 00:06:08,320
Well, how are we going
to solve that problem?

120
00:06:08,320 --> 00:06:09,720
We're going to
solve that problem

121
00:06:09,720 --> 00:06:12,770
by using this incredibly
powerful design

122
00:06:12,770 --> 00:06:16,497
strategy that you've already
seen us use over and over.

123
00:06:16,497 --> 00:06:18,330
And that's the strategy
of wishful thinking.

124
00:06:18,330 --> 00:06:25,624


125
00:06:25,624 --> 00:06:28,040
Just like before when we didn't
have a procedure, we said,

126
00:06:28,040 --> 00:06:31,420
well, let's imagine that that
procedure already exists.

127
00:06:31,420 --> 00:06:36,100
We'll say, well, let's imagine
that we have these clouds.

128
00:06:36,100 --> 00:06:39,250
Now more precisely
what I mean is

129
00:06:39,250 --> 00:06:44,287
let's imagine that we
have three procedures,

130
00:06:44,287 --> 00:06:45,120
one called make-RAT.

131
00:06:45,120 --> 00:06:47,740


132
00:06:47,740 --> 00:06:54,530
make-RAT is going to take
as arguments two numbers,

133
00:06:54,530 --> 00:06:57,990
so I'll call them
numerator and denominator,

134
00:06:57,990 --> 00:07:05,300
and it'll return for us a
cloud-- one of these clouds.

135
00:07:05,300 --> 00:07:07,030
I don't really know
what a cloud is.

136
00:07:07,030 --> 00:07:11,160
It's whatever make-RAT
returns, that's its business.

137
00:07:11,160 --> 00:07:12,660
And then we're going
to say, suppose

138
00:07:12,660 --> 00:07:15,310
we've got one of these clouds,
we have a procedure called

139
00:07:15,310 --> 00:07:20,260
numer, which takes in a cloud
that has an n and a d in it,

140
00:07:20,260 --> 00:07:23,690
whatever a cloud is, and I don't
know what it is, and returns

141
00:07:23,690 --> 00:07:26,980
for us the numerator part.

142
00:07:26,980 --> 00:07:31,250
And then we'll assume we
have a procedure denom,

143
00:07:31,250 --> 00:07:33,025
which again takes
in a cloud, whatever

144
00:07:33,025 --> 00:07:37,850
a cloud is, and returns for us
the denominator [? required. ?]

145
00:07:37,850 --> 00:07:40,710
This is just like
before, when if we're

146
00:07:40,710 --> 00:07:43,230
building a square
root, we assume

147
00:07:43,230 --> 00:07:45,101
that we have good enough.

148
00:07:45,101 --> 00:07:45,600
Right?

149
00:07:45,600 --> 00:07:47,649
And what we'll say is,
we'll go find George,

150
00:07:47,649 --> 00:07:49,690
and we'll say to George,
well, it's your business

151
00:07:49,690 --> 00:07:52,135
to make us these procedures.

152
00:07:52,135 --> 00:07:54,010
And how you choose to
implement these clouds,

153
00:07:54,010 --> 00:07:54,884
that's your problem.

154
00:07:54,884 --> 00:07:55,800
We don't want to know.

155
00:07:55,800 --> 00:07:58,670


156
00:07:58,670 --> 00:08:03,340
Well, having pushed this
task off onto George,

157
00:08:03,340 --> 00:08:05,520
then it's pretty easy
to do the other part.

158
00:08:05,520 --> 00:08:07,950
Once we've got the
clouds, it's pretty easy

159
00:08:07,950 --> 00:08:11,820
to write the thing that does say
addition of rational numbers.

160
00:08:11,820 --> 00:08:17,820
You can just say define,
well, let's say +RAT.

161
00:08:17,820 --> 00:08:21,980


162
00:08:21,980 --> 00:08:28,110
Define +RAT, which will take in
two rational numbers, x and y.

163
00:08:28,110 --> 00:08:31,706
x and y are each these clouds.

164
00:08:31,706 --> 00:08:32,539
And what does it do?

165
00:08:32,539 --> 00:08:35,840
Well, it's going to return
for us a rational number.

166
00:08:35,840 --> 00:08:40,299


167
00:08:40,299 --> 00:08:41,460
What rational number is it?

168
00:08:41,460 --> 00:08:43,659
Well, we've got
the formulas there.

169
00:08:43,659 --> 00:08:52,180
The numerator of it is the sum
of the product of the numerator

170
00:08:52,180 --> 00:08:56,550
of x and the denominator of y.

171
00:08:56,550 --> 00:09:02,580


172
00:09:02,580 --> 00:09:03,950
It's one thing in the sum.

173
00:09:03,950 --> 00:09:06,240
And the other thing
in the numerator

174
00:09:06,240 --> 00:09:19,060
is the product of the numerator
of y and the denominator of x.

175
00:09:19,060 --> 00:09:20,910
The star, close the plus.

176
00:09:20,910 --> 00:09:23,580
Right, that's the first
argument to make-RAT,

177
00:09:23,580 --> 00:09:26,080
which is the numerator of
the thing I'm constructing.

178
00:09:26,080 --> 00:09:28,050
And then the rest
of the thing goes

179
00:09:28,050 --> 00:09:30,940
into make-RAT is the
denominator of the answer, which

180
00:09:30,940 --> 00:09:37,210
is the product of
the denominator of x

181
00:09:37,210 --> 00:09:42,050
and the denominator of y.

182
00:09:42,050 --> 00:09:42,550
Like that.

183
00:09:42,550 --> 00:09:46,001


184
00:09:46,001 --> 00:09:46,500
OK?

185
00:09:46,500 --> 00:09:51,710
So there is the analog of
doing rational number addition.

186
00:09:51,710 --> 00:09:53,732
And it's no problem
at all, assuming

187
00:09:53,732 --> 00:09:54,815
that we have these clouds.

188
00:09:54,815 --> 00:09:59,020


189
00:09:59,020 --> 00:10:02,250
And of course, we can do
multiplication in the same way.

190
00:10:02,250 --> 00:10:05,570


191
00:10:05,570 --> 00:10:11,160
Define how to get the product
of two rational numbers,

192
00:10:11,160 --> 00:10:13,080
call it *RAT.

193
00:10:13,080 --> 00:10:20,420
Takes in two of these
clouds, x and y, it returns

194
00:10:20,420 --> 00:10:25,450
a rational number,
make-RAT, whose numerator

195
00:10:25,450 --> 00:10:32,020
is the product of the
numerators-- numerator of x

196
00:10:32,020 --> 00:10:38,170
times the numerator of y.

197
00:10:38,170 --> 00:10:41,387
And the denominator of the
thing it's going to return

198
00:10:41,387 --> 00:10:42,845
is the product of
the denominators.

199
00:10:42,845 --> 00:10:57,930


200
00:10:57,930 --> 00:11:02,630
Well, except that I haven't
told you what these clouds are,

201
00:11:02,630 --> 00:11:04,489
that's all there is to it.

202
00:11:04,489 --> 00:11:05,280
See, what did I do?

203
00:11:05,280 --> 00:11:08,210
I assumed by wishful
thinking that I

204
00:11:08,210 --> 00:11:10,490
had a new kind of data object.

205
00:11:10,490 --> 00:11:13,950
And in particular,
I assumed I had ways

206
00:11:13,950 --> 00:11:16,360
of creating these data objects.

207
00:11:16,360 --> 00:11:18,140
Make-RAT creates
one of these things.

208
00:11:18,140 --> 00:11:19,348
This is called a constructor.

209
00:11:19,348 --> 00:11:25,720


210
00:11:25,720 --> 00:11:29,750
All right, I have a thing that
constructs such data objects.

211
00:11:29,750 --> 00:11:34,399
And then I assume I have things
that, having made these things,

212
00:11:34,399 --> 00:11:35,940
I have ways of
getting the parts out.

213
00:11:35,940 --> 00:11:37,550
Those are called selectors.

214
00:11:37,550 --> 00:11:42,850


215
00:11:42,850 --> 00:11:44,900
And so formally, what
I said is I assumed

216
00:11:44,900 --> 00:11:47,270
I had procedures
that are constructors

217
00:11:47,270 --> 00:11:49,160
and selectors for
these data objects,

218
00:11:49,160 --> 00:11:52,090
and then I went
off and used them.

219
00:11:52,090 --> 00:11:54,180
That's no different
in kind from saying

220
00:11:54,180 --> 00:11:56,380
I assume I have a
procedure good-enough,

221
00:11:56,380 --> 00:11:58,335
and I go use it to
implement square root.

222
00:11:58,335 --> 00:12:00,850


223
00:12:00,850 --> 00:12:05,250
OK, well before we
go on, let's ask

224
00:12:05,250 --> 00:12:08,660
the question of why do we want
to do this in the first place?

225
00:12:08,660 --> 00:12:16,340
See, why do we want a procedure
like +RAT that takes in two

226
00:12:16,340 --> 00:12:20,044
rational numbers and
returns a rational number?

227
00:12:20,044 --> 00:12:21,960
See, another way to think
about this is, well,

228
00:12:21,960 --> 00:12:22,793
here's this formula.

229
00:12:22,793 --> 00:12:25,160


230
00:12:25,160 --> 00:12:27,740
And I've also got to
implement something

231
00:12:27,740 --> 00:12:29,824
that adds rational numbers.

232
00:12:29,824 --> 00:12:32,240
One other way to think about
is, well, there's this thing,

233
00:12:32,240 --> 00:12:34,750
and I type in four
numbers, an n1, and a d1,

234
00:12:34,750 --> 00:12:36,600
and an n2, and a d2.

235
00:12:36,600 --> 00:12:38,510
And it sets some
registers in the machine

236
00:12:38,510 --> 00:12:42,255
to this numerator
and this denominator.

237
00:12:42,255 --> 00:12:43,630
So I might say,
well, why don't I

238
00:12:43,630 --> 00:12:45,470
just add rational
numbers by I type in four

239
00:12:45,470 --> 00:12:47,220
numbers, numerators
and denominators,

240
00:12:47,220 --> 00:12:48,595
and get out two
numbers, which is

241
00:12:48,595 --> 00:12:51,000
a numerator and a denominator.

242
00:12:51,000 --> 00:12:54,250
Why are we worrying
about building things

243
00:12:54,250 --> 00:12:55,100
like this anyway?

244
00:12:55,100 --> 00:12:58,620


245
00:12:58,620 --> 00:13:00,820
Well, the answer
is, suppose you want

246
00:13:00,820 --> 00:13:06,090
to think about expressing
something like this,

247
00:13:06,090 --> 00:13:10,900
suppose I'd like to
express the idea of taking

248
00:13:10,900 --> 00:13:15,300
two rational numbers,
x plus y, say,

249
00:13:15,300 --> 00:13:23,670
and multiplying that by the sum
of two other rational numbers.

250
00:13:23,670 --> 00:13:28,266
Well, the way I do it, having
things like +RAT and *RAT,

251
00:13:28,266 --> 00:13:33,930
is I'd say, oh yeah, what
that is is just the product.

252
00:13:33,930 --> 00:13:51,570
That's *RAT of the sum of x
and y and the sum of s and t.

253
00:13:51,570 --> 00:13:55,940
So except for syntax,
I get an expression

254
00:13:55,940 --> 00:13:58,380
that looks like the
way I want to think

255
00:13:58,380 --> 00:13:59,490
about it mathematically.

256
00:13:59,490 --> 00:14:02,080
I want to say there
are two numbers.

257
00:14:02,080 --> 00:14:05,407
There's a thing which
is the sum of them,

258
00:14:05,407 --> 00:14:07,490
and there's a thing which
is the sum of these two.

259
00:14:07,490 --> 00:14:10,780
That's this and this.

260
00:14:10,780 --> 00:14:12,474
And then I multiply them.

261
00:14:12,474 --> 00:14:14,640
So I get an expression that
matches this expression.

262
00:14:14,640 --> 00:14:16,600
If I did the other
thing, if I said,

263
00:14:16,600 --> 00:14:18,450
well, the way I want
to think about this

264
00:14:18,450 --> 00:14:20,950
is I type into my machine
four numbers, which

265
00:14:20,950 --> 00:14:24,140
are the numerators and the
denominators of x and y,

266
00:14:24,140 --> 00:14:26,440
and then four more numbers,
which are the numerators

267
00:14:26,440 --> 00:14:28,841
and denominators of s and t.

268
00:14:28,841 --> 00:14:31,340
And then what I'd be sitting
with is, well, what would I do?

269
00:14:31,340 --> 00:14:33,280
I'd add these, and
somehow I'd have

270
00:14:33,280 --> 00:14:36,440
to have two temporary variables,
which are the numerators

271
00:14:36,440 --> 00:14:38,377
and denominators of
this sum, and I'd

272
00:14:38,377 --> 00:14:39,710
go off and store them someplace.

273
00:14:39,710 --> 00:14:42,235


274
00:14:42,235 --> 00:14:44,610
And then I'd go over here,
I'd type in four more numbers,

275
00:14:44,610 --> 00:14:46,720
I'd get two more
temporary variables,

276
00:14:46,720 --> 00:14:50,180
which are the numerators
and denominators of s and t.

277
00:14:50,180 --> 00:14:54,962
And then finally, I put those
together by multiplying them.

278
00:14:54,962 --> 00:14:56,420
You see, what's
starting to happen,

279
00:14:56,420 --> 00:14:58,830
there are all these
temporary variables, which

280
00:14:58,830 --> 00:15:02,060
are sort of the guts
of the internals

281
00:15:02,060 --> 00:15:04,180
of these rational numbers
that start hanging

282
00:15:04,180 --> 00:15:05,997
out all over the system.

283
00:15:05,997 --> 00:15:08,580
And of course, if I had more and
more complicated expressions,

284
00:15:08,580 --> 00:15:10,288
there'd be more and
more guts hanging out

285
00:15:10,288 --> 00:15:13,010
that confuse my programming.

286
00:15:13,010 --> 00:15:15,340
And those of you who
sort of programmed things

287
00:15:15,340 --> 00:15:17,794
like that, where you're just
adding numbers in assembly

288
00:15:17,794 --> 00:15:19,210
language, you sort
of see you have

289
00:15:19,210 --> 00:15:23,040
to suddenly be concerned with
these temporary variables.

290
00:15:23,040 --> 00:15:28,350
But more importantly than
confusing my programming,

291
00:15:28,350 --> 00:15:29,760
they're going to
confuse my mind.

292
00:15:29,760 --> 00:15:33,440
Because the whole
name of this game

293
00:15:33,440 --> 00:15:37,740
is that we'd like the
programming language to express

294
00:15:37,740 --> 00:15:39,670
the concepts that we
have in our heads,

295
00:15:39,670 --> 00:15:43,510
like rational numbers are things
that you can add and then take

296
00:15:43,510 --> 00:15:44,770
that result and multiply them.

297
00:15:44,770 --> 00:15:48,587


298
00:15:48,587 --> 00:15:49,670
Let's break for questions.

299
00:15:49,670 --> 00:15:59,570


300
00:15:59,570 --> 00:16:00,080
Yeah?

301
00:16:00,080 --> 00:16:02,127
AUDIENCE: I don't
quite see the need-

302
00:16:02,127 --> 00:16:04,460
when we had make-RAT with the
numerator and denominator,

303
00:16:04,460 --> 00:16:06,626
we had to have the numerator
and denominator to pass

304
00:16:06,626 --> 00:16:08,677
as parameters to
create the cloud,

305
00:16:08,677 --> 00:16:10,885
and then we extracted to
get back what we had to have

306
00:16:10,885 --> 00:16:11,720
originally.

307
00:16:11,720 --> 00:16:13,740
PROFESSOR: That's right.

308
00:16:13,740 --> 00:16:15,770
So the question
is, I sort of have

309
00:16:15,770 --> 00:16:17,370
the numerator and
the denominator,

310
00:16:17,370 --> 00:16:20,890
why am I worrying about
having the cloud given that I

311
00:16:20,890 --> 00:16:23,500
have to get the pieces out?

312
00:16:23,500 --> 00:16:25,490
That's sort of what I
tried to say at the end,

313
00:16:25,490 --> 00:16:27,740
but let me try and say it
again, because that's really

314
00:16:27,740 --> 00:16:29,390
the crucial question.

315
00:16:29,390 --> 00:16:32,540
The point is, I want to carry
this numerator and denominator

316
00:16:32,540 --> 00:16:36,816
around together all the time.

317
00:16:36,816 --> 00:16:38,716
And it's almost as
if I want to know,

318
00:16:38,716 --> 00:16:40,840
yeah, there's a numerator
and denominator in there,

319
00:16:40,840 --> 00:16:47,420
but also, I would like to say,
fine, but from another point

320
00:16:47,420 --> 00:16:50,180
of view, that's x.

321
00:16:50,180 --> 00:16:53,040
And I carry x around, and I
name it as x, and I hold it.

322
00:16:53,040 --> 00:16:55,897
And I can say things
like, the sum of x and y,

323
00:16:55,897 --> 00:16:58,230
rather than just have-- see,
it's not so bad when I only

324
00:16:58,230 --> 00:17:00,840
think about x, but if
I have a system with 10

325
00:17:00,840 --> 00:17:03,220
rational numbers, suddenly
I have 20 numerators

326
00:17:03,220 --> 00:17:05,481
and denominators, which
are not necessarily--

327
00:17:05,481 --> 00:17:06,980
if I don't link
them, then it's just

328
00:17:06,980 --> 00:17:09,000
20 arbitrary
numbers that are not

329
00:17:09,000 --> 00:17:10,560
linked in any particular way.

330
00:17:10,560 --> 00:17:14,090
It's a lot like saying, well,
I have these instructions

331
00:17:14,090 --> 00:17:15,589
that are the body
of the procedures,

332
00:17:15,589 --> 00:17:17,970
why do I want to package them
and say it's the procedure?

333
00:17:17,970 --> 00:17:19,109
It's exactly the same idea.

334
00:17:19,109 --> 00:17:31,875


335
00:17:31,875 --> 00:17:33,840
No?

336
00:17:33,840 --> 00:17:35,120
OK.

337
00:17:35,120 --> 00:17:38,349
Let's break, let's just stretch
and get somebody-- [INAUDIBLE]

338
00:17:38,349 --> 00:18:27,080
[MUSIC PLAYING]

339
00:18:27,080 --> 00:18:30,310
OK, well, we've been working on
this rational number arithmetic

340
00:18:30,310 --> 00:18:34,730
system, and then what we
did, the important thing

341
00:18:34,730 --> 00:18:37,310
about what we did, is we
thought about the problem

342
00:18:37,310 --> 00:18:40,160
by breaking it into two pieces.

343
00:18:40,160 --> 00:18:43,410
We said, assume there is
this contract with George,

344
00:18:43,410 --> 00:18:45,230
and George has
figured out the way

345
00:18:45,230 --> 00:18:47,920
to how to construct
these clouds,

346
00:18:47,920 --> 00:18:50,690
provided us procedures
make-RAT, which

347
00:18:50,690 --> 00:18:53,790
was a constructor,
and selectors, which

348
00:18:53,790 --> 00:18:55,040
are numerator and denominator.

349
00:18:55,040 --> 00:18:56,623
And then in terms
of that, we went off

350
00:18:56,623 --> 00:18:58,580
and implemented addition
and multiplication

351
00:18:58,580 --> 00:19:00,630
of rational numbers.

352
00:19:00,630 --> 00:19:03,640
Well, now let's go look
at George's problem.

353
00:19:03,640 --> 00:19:05,660
How can we go and
package together

354
00:19:05,660 --> 00:19:08,150
a numerator and a
denominator and actually make

355
00:19:08,150 --> 00:19:09,360
one of these clouds?

356
00:19:09,360 --> 00:19:15,760
See, what we need is a kind of
glue, a glue for data objects

357
00:19:15,760 --> 00:19:18,040
that allows us to
put things together.

358
00:19:18,040 --> 00:19:23,134
And Lisp provides such
a glue, and that glue

359
00:19:23,134 --> 00:19:24,175
is called list structure.

360
00:19:24,175 --> 00:19:30,410


361
00:19:30,410 --> 00:19:32,940
List structure is a
way of gluing things

362
00:19:32,940 --> 00:19:37,690
together, and more
precisely, Lisp

363
00:19:37,690 --> 00:19:41,540
provides a way of constructing
things called pairs.

364
00:19:41,540 --> 00:19:44,750


365
00:19:44,750 --> 00:19:52,222
There's a primitive operator
in Lisp called cons.

366
00:19:52,222 --> 00:19:54,920
We can take a look at it.

367
00:19:54,920 --> 00:19:57,170
There's a thing called cons.

368
00:19:57,170 --> 00:20:00,620


369
00:20:00,620 --> 00:20:03,880
Cons is an operator which
takes in two arguments called

370
00:20:03,880 --> 00:20:08,800
x and y, and it returns for
us a thing called a pair.

371
00:20:08,800 --> 00:20:11,510


372
00:20:11,510 --> 00:20:17,300
All right, so a thing called
a pair that has a first part

373
00:20:17,300 --> 00:20:18,100
a second part.

374
00:20:18,100 --> 00:20:22,250


375
00:20:22,250 --> 00:20:25,450
So cons takes two objects.

376
00:20:25,450 --> 00:20:26,780
There's a thing called a pair.

377
00:20:26,780 --> 00:20:31,100
The first part of the cons is x,
and the second part of the cons

378
00:20:31,100 --> 00:20:31,600
is y.

379
00:20:31,600 --> 00:20:34,090
And that's what it builds.

380
00:20:34,090 --> 00:20:36,880
And then we also assume we have
ways of getting things out.

381
00:20:36,880 --> 00:20:41,820
If you're given a pair,
there's a thing called car,

382
00:20:41,820 --> 00:20:44,250
and car of a pair,
p, gives you out

383
00:20:44,250 --> 00:20:46,640
the first part of the pair, p.

384
00:20:46,640 --> 00:20:49,650
And there's a thing called
cdr, and cdr of the pair, p,

385
00:20:49,650 --> 00:20:54,310
gives you the second
part of the pair, p.

386
00:20:54,310 --> 00:20:56,710
OK, so that's how
we construct things.

387
00:20:56,710 --> 00:21:01,620
There's also a conventional
way of drawing pictures

388
00:21:01,620 --> 00:21:02,800
of these things.

389
00:21:02,800 --> 00:21:10,140
Just like we write down that as
the conventional way of writing

390
00:21:10,140 --> 00:21:16,890
Plato's idea of two,
the way we could

391
00:21:16,890 --> 00:21:21,510
draw a diagram to represent cons
of two and three is like this.

392
00:21:21,510 --> 00:21:23,912
We draw a little box.

393
00:21:23,912 --> 00:21:26,510
And so here's the box
we're talking about,

394
00:21:26,510 --> 00:21:30,070
and this box has two
arrows coming out of it.

395
00:21:30,070 --> 00:21:35,180
And say the first part
of this pair is 2,

396
00:21:35,180 --> 00:21:38,250
and the second part
of this pair is 3.

397
00:21:38,250 --> 00:21:40,950
And this notation
has a name, it's

398
00:21:40,950 --> 00:21:44,855
called box and pointer notation.

399
00:21:44,855 --> 00:21:55,942


400
00:21:55,942 --> 00:21:58,150
By the way, let me say right
now that a lot of people

401
00:21:58,150 --> 00:22:00,590
get confused that
there's some significance

402
00:22:00,590 --> 00:22:03,534
to the geometric way I drew
these pointers, the directions.

403
00:22:03,534 --> 00:22:05,200
Like some people think
it'd be different

404
00:22:05,200 --> 00:22:07,650
if I took this pointer
and turned it up here,

405
00:22:07,650 --> 00:22:08,660
and put the 3 out here.

406
00:22:08,660 --> 00:22:10,440
That has no significance.

407
00:22:10,440 --> 00:22:10,940
All right?

408
00:22:10,940 --> 00:22:13,040
It's merely you have
a bunch of arrows,

409
00:22:13,040 --> 00:22:15,090
these pointers, and the boxes.

410
00:22:15,090 --> 00:22:17,390
The only issue is how
they're connected,

411
00:22:17,390 --> 00:22:19,720
not the geometric
arrangement of whether I

412
00:22:19,720 --> 00:22:23,160
write the pointer
across, or up, or down.

413
00:22:23,160 --> 00:22:26,490
Now it's completely
un-obvious, probably,

414
00:22:26,490 --> 00:22:28,337
why that's called
list structure.

415
00:22:28,337 --> 00:22:30,420
We're not actually going
to talk about that today.

416
00:22:30,420 --> 00:22:31,850
We'll see that next time.

417
00:22:31,850 --> 00:22:37,870


418
00:22:37,870 --> 00:22:41,740
So those are pairs, there's
cons that constructs them.

419
00:22:41,740 --> 00:22:45,640
And what I'm going to know
about cons, and car, and cdr,

420
00:22:45,640 --> 00:22:51,170
is precisely that if I have
any x and y, all right,

421
00:22:51,170 --> 00:22:55,800
if I have any things x and y,
and I use cons to construct

422
00:22:55,800 --> 00:23:01,200
a pair, then the
car of that pair

423
00:23:01,200 --> 00:23:03,920
is going to be x,
the thing I put in,

424
00:23:03,920 --> 00:23:07,790
and the cdr of that
pair is going to be y.

425
00:23:07,790 --> 00:23:12,360
That's the behavior of these
operators, cons, car, and cdr.

426
00:23:12,360 --> 00:23:13,960
Given them, it's
pretty clear how

427
00:23:13,960 --> 00:23:17,520
George can go off and
construct his rational numbers.

428
00:23:17,520 --> 00:23:19,580
After all, all he
has to do-- remember

429
00:23:19,580 --> 00:23:22,520
George's problem was to
implement make-RAT, numerator,

430
00:23:22,520 --> 00:23:23,320
and denom.

431
00:23:23,320 --> 00:23:29,410
So all George has
to do is say define

432
00:23:29,410 --> 00:23:40,710
make-RAT of some n and a d-- so
all I have to do is cons them.

433
00:23:40,710 --> 00:23:42,790
That's cons of n and d.

434
00:23:42,790 --> 00:23:45,365


435
00:23:45,365 --> 00:23:46,990
And then if I want
to get the numerator

436
00:23:46,990 --> 00:23:57,340
out, I would say define
the numerator, numer,

437
00:23:57,340 --> 00:24:00,260
of some rational number, x.

438
00:24:00,260 --> 00:24:02,510
If the rational number's
implemented as a pair,

439
00:24:02,510 --> 00:24:06,190
then all I have to do
is get out the car of x.

440
00:24:06,190 --> 00:24:19,350
And then similarly, define the
denom is going to be the cdr,

441
00:24:19,350 --> 00:24:21,430
the other thing I
put into the pair.

442
00:24:21,430 --> 00:24:27,080


443
00:24:27,080 --> 00:24:28,960
Well, now we're in business.

444
00:24:28,960 --> 00:24:33,810
That's a complete implementation
of rational numbers.

445
00:24:33,810 --> 00:24:34,410
Let's use it.

446
00:24:34,410 --> 00:24:36,540
Suppose I want to say,
so I want to think

447
00:24:36,540 --> 00:24:43,470
about how to add 1/2 plus 1/4
and watch the system work.

448
00:24:43,470 --> 00:24:50,780
Well, the way I'd use that is
I'd say, well, maybe define a.

449
00:24:50,780 --> 00:24:53,080
I have to make a 1/2.

450
00:24:53,080 --> 00:24:55,830
Well, that's a rational
number with numerator 1

451
00:24:55,830 --> 00:25:01,090
and denominator 2, so a
will be make-RAT of 1 and 2.

452
00:25:01,090 --> 00:25:05,490


453
00:25:05,490 --> 00:25:07,770
And then I'll construct the 1/4.

454
00:25:07,770 --> 00:25:20,560
I'll say define d to
be make-RAT of 1 and 4.

455
00:25:20,560 --> 00:25:23,362


456
00:25:23,362 --> 00:25:25,630
And if I'd like to look
at the answer-- well,

457
00:25:25,630 --> 00:25:28,110
assuming I don't have a special
thing that prints rational

458
00:25:28,110 --> 00:25:31,530
numbers, or I could make one--
I could say, for instance,

459
00:25:31,530 --> 00:25:46,930
define the answer to be +RAT
of a and b, and now I can say,

460
00:25:46,930 --> 00:25:47,790
what's the answer?

461
00:25:47,790 --> 00:25:50,900
What are the numerators and
denominators of the answer?

462
00:25:50,900 --> 00:25:54,470
So if I'm adding
1/2 and 1/4, I'll

463
00:25:54,470 --> 00:26:00,440
say, what is the
numerator of the answer?

464
00:26:00,440 --> 00:26:04,230


465
00:26:04,230 --> 00:26:10,880
And the system is going
to type out, well, 6.

466
00:26:10,880 --> 00:26:13,250
Bad news.

467
00:26:13,250 --> 00:26:22,340
And if I say what's the
denominator of the answer,

468
00:26:22,340 --> 00:26:26,430
the system's going
to type out 8.

469
00:26:26,430 --> 00:26:29,930
So instead of what
I would really like,

470
00:26:29,930 --> 00:26:35,630
which is for it to say
that 1/2 and 1/4 is 3/4,

471
00:26:35,630 --> 00:26:40,450
this foolish machine is
going to say, no, it's 6/8.

472
00:26:40,450 --> 00:26:43,400
Well, that's sort of bad news.

473
00:26:43,400 --> 00:26:44,220
Where's the bug?

474
00:26:44,220 --> 00:26:47,280


475
00:26:47,280 --> 00:26:48,780
Why does it do that, after all?

476
00:26:48,780 --> 00:26:51,400
Well, it's the way
that we just had +RAT.

477
00:26:51,400 --> 00:26:56,210
+RAT just took the-- it said
you add the numerator times

478
00:26:56,210 --> 00:26:59,450
the denominator, you add
that to the numerator times

479
00:26:59,450 --> 00:27:02,210
the denominator, and put that
over the product of the two

480
00:27:02,210 --> 00:27:05,890
denominators, and
that's why you get 6/8.

481
00:27:05,890 --> 00:27:10,489
So what was wrong with our
implementation of +RAT?

482
00:27:10,489 --> 00:27:12,780
What's wrong with that rational
number arithmetic stuff

483
00:27:12,780 --> 00:27:15,582
that we did before the break?

484
00:27:15,582 --> 00:27:17,290
Well, the answer is
one way to look at it

485
00:27:17,290 --> 00:27:19,529
is absolutely nothing's wrong.

486
00:27:19,529 --> 00:27:21,070
That's perfectly
good implementation.

487
00:27:21,070 --> 00:27:25,901
It follows the sixth grade,
fifth grade mathematic

488
00:27:25,901 --> 00:27:26,775
for adding fractions.

489
00:27:26,775 --> 00:27:30,000


490
00:27:30,000 --> 00:27:33,310
One thing we can say is,
well, that's George's problem.

491
00:27:33,310 --> 00:27:36,250
Like, boy, wasn't
George dumb to say

492
00:27:36,250 --> 00:27:38,440
that he can make a
rational number simply

493
00:27:38,440 --> 00:27:42,900
by sticking together the
numerator and the denominator?

494
00:27:42,900 --> 00:27:45,360
Wouldn't it be
better for George,

495
00:27:45,360 --> 00:27:48,420
when he made a rational
number, to reduce

496
00:27:48,420 --> 00:27:50,970
the stuff to lowest terms?

497
00:27:50,970 --> 00:27:55,750
And what I mean is, wouldn't
it be better for George,

498
00:27:55,750 --> 00:28:00,430
instead of using this
version of make-RAT,

499
00:28:00,430 --> 00:28:03,580
to use this one on the slide?

500
00:28:03,580 --> 00:28:09,190
Or instead of just saying cons
together n and d, what you do

501
00:28:09,190 --> 00:28:12,800
is compute the greatest
common divisor of n and d,

502
00:28:12,800 --> 00:28:15,471
and gcd is the procedure
which, well, for all we

503
00:28:15,471 --> 00:28:17,470
care is a primitive, which
computes the greatest

504
00:28:17,470 --> 00:28:20,628
common divisor of two numbers.

505
00:28:20,628 --> 00:28:24,520
So the way I can construct
a rational number is

506
00:28:24,520 --> 00:28:26,890
get the greatest common
divisor of the two numbers,

507
00:28:26,890 --> 00:28:30,530
and I'm going to
call that g, and then

508
00:28:30,530 --> 00:28:32,959
instead of consing
together n and d,

509
00:28:32,959 --> 00:28:34,000
I'll divide them through.

510
00:28:34,000 --> 00:28:35,499
I'll cons together
the quotient of n

511
00:28:35,499 --> 00:28:40,454
by the the gcd and the
quotient of d by the gcd.

512
00:28:40,454 --> 00:28:42,120
And that will reduce
the rational number

513
00:28:42,120 --> 00:28:43,000
to lowest terms.

514
00:28:43,000 --> 00:28:47,780


515
00:28:47,780 --> 00:28:54,330
So when I do this addition,
when +RAT calls make-RAT--

516
00:28:54,330 --> 00:28:57,685
and for the definition of +RAT
it had a make-RAT in there--

517
00:28:57,685 --> 00:28:59,560
just by the fact that
it's constructing that,

518
00:28:59,560 --> 00:29:01,935
the thing will get reduced to
lowest terms automatically.

519
00:29:01,935 --> 00:29:09,612


520
00:29:09,612 --> 00:29:15,180
OK, that is a complete system.

521
00:29:15,180 --> 00:29:19,590
For rational number arithmetic,
let's look at what we've done.

522
00:29:19,590 --> 00:29:22,440
All right, we said we want
to build rational number

523
00:29:22,440 --> 00:29:27,230
arithmetic, and we had
a thing called +RAT.

524
00:29:27,230 --> 00:29:29,940
We implemented that.

525
00:29:29,940 --> 00:29:33,330
And I showed you multiplying
rational numbers,

526
00:29:33,330 --> 00:29:35,317
and although I didn't
put them up there,

527
00:29:35,317 --> 00:29:36,900
presumably we'd like
to have something

528
00:29:36,900 --> 00:29:39,937
that subtracts rational
numbers, and I don't know,

529
00:29:39,937 --> 00:29:40,770
all sorts of things.

530
00:29:40,770 --> 00:29:43,270
Things that test equality in
division, and maybe things that

531
00:29:43,270 --> 00:29:46,190
print rational numbers
in some particular way.

532
00:29:46,190 --> 00:29:52,330
And we implemented
those in terms of pairs.

533
00:29:52,330 --> 00:29:55,800
These pairs, cons, car, and
cdr that are built into Lisp.

534
00:29:55,800 --> 00:30:05,100
But the important thing is
that between these and these,

535
00:30:05,100 --> 00:30:07,622
we set up an
abstraction barrier.

536
00:30:07,622 --> 00:30:09,260
We set up a layer
of abstraction.

537
00:30:09,260 --> 00:30:17,310


538
00:30:17,310 --> 00:30:19,190
And what was that
layer of abstraction?

539
00:30:19,190 --> 00:30:21,795
That layer of abstraction
was precisely the constructor

540
00:30:21,795 --> 00:30:22,545
and the selectors.

541
00:30:22,545 --> 00:30:25,630


542
00:30:25,630 --> 00:30:34,730
This layer was make-RAT,
and numer, and denom.

543
00:30:34,730 --> 00:30:38,970


544
00:30:38,970 --> 00:30:43,480
This methodology, another
way to say what it's doing,

545
00:30:43,480 --> 00:30:53,520
is that we are separating
the way something is used,

546
00:30:53,520 --> 00:30:56,380
separating the use
of data objects,

547
00:30:56,380 --> 00:30:59,350
from the representation
of data objects.

548
00:30:59,350 --> 00:31:07,650


549
00:31:07,650 --> 00:31:11,440
So up here, we have the way
that rational numbers are used,

550
00:31:11,440 --> 00:31:12,620
do arithmetic on them.

551
00:31:12,620 --> 00:31:15,140
Down here, we have the way
that they're represented,

552
00:31:15,140 --> 00:31:17,647
and they're separated
by this boundary.

553
00:31:17,647 --> 00:31:19,605
The boundary is the
constructors and selectors.

554
00:31:19,605 --> 00:31:23,760


555
00:31:23,760 --> 00:31:25,597
And this methodology has a name.

556
00:31:25,597 --> 00:31:26,930
This is called data abstraction.

557
00:31:26,930 --> 00:31:35,820


558
00:31:35,820 --> 00:31:38,920
Data abstraction is sort of
the programming methodology

559
00:31:38,920 --> 00:31:41,960
of setting up data objects
by postulating constructors

560
00:31:41,960 --> 00:31:44,085
and selectors to isolate
use from representation.

561
00:31:44,085 --> 00:31:47,550


562
00:31:47,550 --> 00:31:49,060
Well, so why?

563
00:31:49,060 --> 00:31:51,750
I mean, after all, we didn't
have to do it this way.

564
00:31:51,750 --> 00:31:55,450
It's perfectly possible to
do rational number addition

565
00:31:55,450 --> 00:31:58,930
without having any compound data
objects, and here on the slide

566
00:31:58,930 --> 00:32:00,060
is one example.

567
00:32:00,060 --> 00:32:03,220
We certainly could
have defined +RAT,

568
00:32:03,220 --> 00:32:06,456
which takes in things
x and y, and we'll say,

569
00:32:06,456 --> 00:32:10,030
well what are these
rational numbers really?

570
00:32:10,030 --> 00:32:12,730
So really, they're just
pairs, and the numerator's

571
00:32:12,730 --> 00:32:15,120
the car and the denominator's
the cdr. So what we'll do

572
00:32:15,120 --> 00:32:23,310
is we'll take the car of x times
the cdr of y, multiply them.

573
00:32:23,310 --> 00:32:26,470
Take the car of y times the
cdr of x, multiply them.

574
00:32:26,470 --> 00:32:28,650
Add them.

575
00:32:28,650 --> 00:32:30,550
Take the cdr of x
and the cdr of y,

576
00:32:30,550 --> 00:32:32,930
multiply them, and then
constitute together.

577
00:32:32,930 --> 00:32:35,265


578
00:32:35,265 --> 00:32:36,890
Well, that sort of
does the same thing.

579
00:32:36,890 --> 00:32:41,560


580
00:32:41,560 --> 00:32:43,550
But this ignores the
problem of reducing things

581
00:32:43,550 --> 00:32:47,680
to lowest terms, but let's not
worry about that for a minute.

582
00:32:47,680 --> 00:32:48,200
But so what?

583
00:32:48,200 --> 00:32:50,461
Why don't we do it that way?

584
00:32:50,461 --> 00:32:50,960
Right?

585
00:32:50,960 --> 00:32:53,220
After all, there are sort of
fewer procedures to define,

586
00:32:53,220 --> 00:32:54,719
and it's a lot more
straightforward.

587
00:32:54,719 --> 00:32:57,210


588
00:32:57,210 --> 00:32:59,240
It saves all this
self-righteous BS

589
00:32:59,240 --> 00:33:00,850
about talking about
data abstraction.

590
00:33:00,850 --> 00:33:02,270
We just sort of do it.

591
00:33:02,270 --> 00:33:04,870
I mean, who knows, maybe it's
even marginally more efficient

592
00:33:04,870 --> 00:33:07,930
depending on whatever
compiler were using for this.

593
00:33:07,930 --> 00:33:11,230
What's the point of
isolating the use

594
00:33:11,230 --> 00:33:13,910
from the representation?

595
00:33:13,910 --> 00:33:17,130
Well, it goes back to
this notion of naming.

596
00:33:17,130 --> 00:33:20,870
Remember, one of the
most important principles

597
00:33:20,870 --> 00:33:23,030
in programming is
the same as one

598
00:33:23,030 --> 00:33:25,660
of the most important principles
in sorcery, all right?

599
00:33:25,660 --> 00:33:27,930
That's if you have the
name of the spirit,

600
00:33:27,930 --> 00:33:30,330
you get control over it.

601
00:33:30,330 --> 00:33:33,790
And if you go back
and look at the slide,

602
00:33:33,790 --> 00:33:36,940
you see what's in there is
we have this thing +RAT,

603
00:33:36,940 --> 00:33:40,600
but nowhere in the system,
if I have a +RAT and a -RAT

604
00:33:40,600 --> 00:33:42,580
and a *RAT, and things
that look like that,

605
00:33:42,580 --> 00:33:46,030
nowhere in the system do I
have a thing that I can point

606
00:33:46,030 --> 00:33:50,770
at which is a rational number.

607
00:33:50,770 --> 00:33:53,550


608
00:33:53,550 --> 00:33:57,170
I don't have, in a
system like that,

609
00:33:57,170 --> 00:34:01,340
the idea of rational number
as a conceptual entity.

610
00:34:01,340 --> 00:34:04,270
Well, what's the
advantage of that?

611
00:34:04,270 --> 00:34:05,920
What's the advantage
of isolating

612
00:34:05,920 --> 00:34:08,360
the idea of rational numbers
as a conceptual entity,

613
00:34:08,360 --> 00:34:10,929
and really naming it
with make-RAT, numerator,

614
00:34:10,929 --> 00:34:12,900
and denominator.

615
00:34:12,900 --> 00:34:18,230
Well, one advantage is
you might want to have

616
00:34:18,230 --> 00:34:20,679
alternative representations.

617
00:34:20,679 --> 00:34:23,520
See, before I showed you
that one way George can solve

618
00:34:23,520 --> 00:34:26,920
this things not reduced
to lowest terms problem,

619
00:34:26,920 --> 00:34:29,149
is when you build
a rational number,

620
00:34:29,149 --> 00:34:31,190
you divide up by the
greatest common denominator.

621
00:34:31,190 --> 00:34:36,634
Another way to do that
is shown over here.

622
00:34:36,634 --> 00:34:38,300
I can have an alternative
representation

623
00:34:38,300 --> 00:34:40,980
for rational numbers where when
you make a rational number,

624
00:34:40,980 --> 00:34:43,409
you just cons them.

625
00:34:43,409 --> 00:34:45,040
However, when you
go to select out

626
00:34:45,040 --> 00:34:50,409
the numerator, at that point
you compute the gcd of the stuff

627
00:34:50,409 --> 00:34:53,440
that's sitting in that pair,
and divide out by the gcd.

628
00:34:53,440 --> 00:34:57,970


629
00:34:57,970 --> 00:35:01,090
And similarly, when I
get the denominator,

630
00:35:01,090 --> 00:35:03,600
at that point when I go
to get the denominator,

631
00:35:03,600 --> 00:35:05,420
I'll divide out by the gcd.

632
00:35:05,420 --> 00:35:09,090
So the difference would be in
the old representation, when

633
00:35:09,090 --> 00:35:13,170
ans was constructed
here, say what's 6 and 8,

634
00:35:13,170 --> 00:35:15,054
in the first way,
the 6 and 8 would

635
00:35:15,054 --> 00:35:17,220
have got reduced when they
got stuck into that pair,

636
00:35:17,220 --> 00:35:20,165
numerator would select out 3.

637
00:35:20,165 --> 00:35:21,540
And in the way I
just showed you,

638
00:35:21,540 --> 00:35:25,110
well, ans would
get 6 and 8 put in,

639
00:35:25,110 --> 00:35:27,650
and then at the point
where I said numerator,

640
00:35:27,650 --> 00:35:32,590
some computation would get
done to put out 3 instead of 6.

641
00:35:32,590 --> 00:35:34,520
So those are two different
ways I might do it.

642
00:35:34,520 --> 00:35:37,461
Which one's better?

643
00:35:37,461 --> 00:35:38,460
Well, it depends, right?

644
00:35:38,460 --> 00:35:40,642
If I'm making a system
where I am mostly

645
00:35:40,642 --> 00:35:42,850
constructing rational numbers
and hardly ever looking

646
00:35:42,850 --> 00:35:44,266
at them, then it's
probably better

647
00:35:44,266 --> 00:35:47,776
not to do that gcd computation
when I construct them.

648
00:35:47,776 --> 00:35:50,910
If I'm doing a system where
I look at things a lot more

649
00:35:50,910 --> 00:35:53,030
than I construct them,
then it's probably better

650
00:35:53,030 --> 00:35:57,087
to do the work when
I construct them.

651
00:35:57,087 --> 00:35:58,170
So there's a choice there.

652
00:35:58,170 --> 00:36:01,780
But the real issue
is that you might not

653
00:36:01,780 --> 00:36:05,640
be able to decide at the
moment you're worrying

654
00:36:05,640 --> 00:36:07,640
about these rational numbers.

655
00:36:07,640 --> 00:36:13,430
See, in general, as
systems designers,

656
00:36:13,430 --> 00:36:15,900
you're forced with the
necessity to make decisions

657
00:36:15,900 --> 00:36:18,010
about how you're
going to do things,

658
00:36:18,010 --> 00:36:20,880
and in general, the way you'd
like to retain flexibility

659
00:36:20,880 --> 00:36:23,990
is to never make up
your mind about anything

660
00:36:23,990 --> 00:36:26,890
until you're forced to do it.

661
00:36:26,890 --> 00:36:31,350
The problem is, there's
a very, very narrow line

662
00:36:31,350 --> 00:36:34,765
between deferring decisions
and outright procrastination.

663
00:36:34,765 --> 00:36:38,760


664
00:36:38,760 --> 00:36:44,080
So you'd like to make progress,
but also at the same time,

665
00:36:44,080 --> 00:36:48,620
never be bound by the
consequences of your decisions.

666
00:36:48,620 --> 00:36:50,550
Data abstraction's
one way of doing this.

667
00:36:50,550 --> 00:36:54,540
What we did is we
used wishful thinking.

668
00:36:54,540 --> 00:36:57,190
See, we gave a name
to the decision.

669
00:36:57,190 --> 00:37:00,505
We said, make-RAT,
numerator, and denominator

670
00:37:00,505 --> 00:37:02,380
will stand for however
it's going to be done,

671
00:37:02,380 --> 00:37:04,630
and however it's going to
be done is George's problem.

672
00:37:04,630 --> 00:37:06,890
But really, what that was
doing is giving a name

673
00:37:06,890 --> 00:37:10,380
to the decision of how
we're going to do it,

674
00:37:10,380 --> 00:37:14,400
and then continuing as
if we made the decision.

675
00:37:14,400 --> 00:37:17,110
And then eventually, when
we really wanted it to work,

676
00:37:17,110 --> 00:37:20,330
coming back and facing
what we really had to do.

677
00:37:20,330 --> 00:37:22,690
And in fact, we'll see
a couple times from now

678
00:37:22,690 --> 00:37:24,120
that you may never
have to choose

679
00:37:24,120 --> 00:37:27,800
any particular
representation, ever, ever.

680
00:37:27,800 --> 00:37:30,004
Anyway, that's a very
powerful design technique.

681
00:37:30,004 --> 00:37:32,295
It's the key to the reason
people use data abstraction.

682
00:37:32,295 --> 00:37:34,830


683
00:37:34,830 --> 00:37:37,854
And we're going to see
that idea again and again.

684
00:37:37,854 --> 00:37:40,510
Let's stop for questions.

685
00:37:40,510 --> 00:37:43,600
AUDIENCE: What does
this decision making

686
00:37:43,600 --> 00:37:47,500
through abstraction layers do to
the axiom of do all your design

687
00:37:47,500 --> 00:37:49,800
before any of your code?

688
00:37:49,800 --> 00:37:52,282
PROFESSOR: Well,
that's someone's axiom,

689
00:37:52,282 --> 00:37:53,990
and I bet that's the
axiom of someone who

690
00:37:53,990 --> 00:37:56,600
hasn't implemented very large
computer systems very much.

691
00:37:56,600 --> 00:38:01,220


692
00:38:01,220 --> 00:38:03,460
I said that computer
science is a lot like magic,

693
00:38:03,460 --> 00:38:05,270
and it's sort of good
that it's like magic.

694
00:38:05,270 --> 00:38:06,853
There's a bad part
of computer science

695
00:38:06,853 --> 00:38:08,746
that's a lot like religion.

696
00:38:08,746 --> 00:38:12,637
And in general, I
think people who

697
00:38:12,637 --> 00:38:15,220
really believe that you design
everything before you implement

698
00:38:15,220 --> 00:38:17,732
it basically are people
who haven't designed

699
00:38:17,732 --> 00:38:18,440
very many things.

700
00:38:18,440 --> 00:38:21,230


701
00:38:21,230 --> 00:38:23,870
The real power is
that you can pretend

702
00:38:23,870 --> 00:38:27,000
that you've made the
decision and then later

703
00:38:27,000 --> 00:38:29,530
on figure out which one is
right, which decision you ought

704
00:38:29,530 --> 00:38:30,412
to have made.

705
00:38:30,412 --> 00:38:32,870
And when you can do that, you
have the best of both worlds.

706
00:38:32,870 --> 00:38:35,664


707
00:38:35,664 --> 00:38:37,330
AUDIENCE: Can you
explain the difference

708
00:38:37,330 --> 00:38:40,180
between let and define?

709
00:38:40,180 --> 00:38:43,520
PROFESSOR: Oh, OK.

710
00:38:43,520 --> 00:38:49,040
Let is a way to
establish local names.

711
00:38:49,040 --> 00:38:55,150


712
00:38:55,150 --> 00:38:57,430
Let me give you sort
of the half answer.

713
00:38:57,430 --> 00:39:00,970
And I'll say, later on we
can talk about the whole very

714
00:39:00,970 --> 00:39:02,960
complicated thing.

715
00:39:02,960 --> 00:39:05,750
But the big difference
for now is that, see,

716
00:39:05,750 --> 00:39:08,130
when you're typing
at Lisp, you're

717
00:39:08,130 --> 00:39:12,020
typing in this environment
where you're making definitions.

718
00:39:12,020 --> 00:39:20,446
And when you say define a to be
5, if I say define a to be 5,

719
00:39:20,446 --> 00:39:25,640
then from then on the thing
will remember that a is 5.

720
00:39:25,640 --> 00:39:29,210
Let is a way to set up
a local context where

721
00:39:29,210 --> 00:39:31,090
there's a definition.

722
00:39:31,090 --> 00:39:37,490
So if I type something
like, saying let a-- no,

723
00:39:37,490 --> 00:39:43,360
I shouldn't say
a-- if I said let z

724
00:39:43,360 --> 00:39:53,730
be 10, and within that context,
tell me what the sum of z and z

725
00:39:53,730 --> 00:39:54,280
is.

726
00:39:54,280 --> 00:40:00,240
So if I typed in this expression
to Lisp, and then this

727
00:40:00,240 --> 00:40:02,210
would put out 20.

728
00:40:02,210 --> 00:40:05,975
However, then if
I said what's z,

729
00:40:05,975 --> 00:40:10,910
the computer would say
that's an unbound variable.

730
00:40:10,910 --> 00:40:13,260
So let is a way of
setting up a context where

731
00:40:13,260 --> 00:40:16,320
you can make definitions.

732
00:40:16,320 --> 00:40:19,320
But those definitions are
local to this context.

733
00:40:19,320 --> 00:40:27,990
And of course, if I'd said
a in here, I'd still get 20.

734
00:40:27,990 --> 00:40:33,859
But this a would not interfere
at all with this one.

735
00:40:33,859 --> 00:40:36,400
So if I type this, and then type
this, and then say what's a?

736
00:40:36,400 --> 00:40:39,160
a will still be 5.

737
00:40:39,160 --> 00:40:41,510
So there's some other
subtle differences

738
00:40:41,510 --> 00:40:44,543
between let and define, but
that's the most important one.

739
00:40:44,543 --> 00:41:20,090


740
00:41:20,090 --> 00:41:23,800
All right, well, we've looked at
implementing this little system

741
00:41:23,800 --> 00:41:26,210
for doing arithmetic
on rational numbers

742
00:41:26,210 --> 00:41:28,740
as an example of this
methodology of data

743
00:41:28,740 --> 00:41:31,096
abstraction.

744
00:41:31,096 --> 00:41:36,870
And that's a way of controlling
complexity in large systems.

745
00:41:36,870 --> 00:41:38,935
But, see, like
procedure definition,

746
00:41:38,935 --> 00:41:40,310
and like all the
ways we're going

747
00:41:40,310 --> 00:41:42,370
to talk about for
controlling complexity,

748
00:41:42,370 --> 00:41:46,370
the real power of these things
show up not when you sort of do

749
00:41:46,370 --> 00:41:49,880
these things in themselves,
like it's not such a great thing

750
00:41:49,880 --> 00:41:52,430
that we've done rational
number arithmetic,

751
00:41:52,430 --> 00:41:56,670
it's that you can use
these as building blocks

752
00:41:56,670 --> 00:42:00,620
for making more
complicated things.

753
00:42:00,620 --> 00:42:03,266
So it's no wonderful idea that
you can just put two numbers

754
00:42:03,266 --> 00:42:04,265
together to form a pair.

755
00:42:04,265 --> 00:42:06,020
If that's all you
ever wanted to do,

756
00:42:06,020 --> 00:42:08,450
there are tons of ways
that you can do that.

757
00:42:08,450 --> 00:42:11,490
The real issue is can
you do that in such a way

758
00:42:11,490 --> 00:42:13,080
so that the things
that you build

759
00:42:13,080 --> 00:42:16,945
become building blocks for doing
something even more complex?

760
00:42:16,945 --> 00:42:18,640
So whenever someone
shows you a method

761
00:42:18,640 --> 00:42:20,690
for controlling complexity, you
should say, yeah, that's great,

762
00:42:20,690 --> 00:42:21,930
but what can I build with it?

763
00:42:21,930 --> 00:42:25,290


764
00:42:25,290 --> 00:42:30,632
So for example, let me just run
through another thing that's

765
00:42:30,632 --> 00:42:32,090
a lot like the
rational number one.

766
00:42:32,090 --> 00:42:35,760
Suppose we would like to
represent points in the plane.

767
00:42:35,760 --> 00:42:37,550
You sort of say,
well, there's a point,

768
00:42:37,550 --> 00:42:40,810
and we're going to
call that point p.

769
00:42:40,810 --> 00:42:47,360
And that point might
have coordinates,

770
00:42:47,360 --> 00:42:50,330
like this might be
the point 1 comma 2.

771
00:42:50,330 --> 00:42:54,370
The x-coordinate might be 1, and
it's y-coordinate might be 2.

772
00:42:54,370 --> 00:42:57,620
And we'll make a little
system for manipulating points

773
00:42:57,620 --> 00:43:00,450
in the plane.

774
00:43:00,450 --> 00:43:03,000
And again, we can
do that-- here's

775
00:43:03,000 --> 00:43:04,120
a little example of that.

776
00:43:04,120 --> 00:43:07,070


777
00:43:07,070 --> 00:43:10,080
It can represent vectors, the
same as points in the plane,

778
00:43:10,080 --> 00:43:18,160
and we'll say, yep, there's a
constructor called make-vector,

779
00:43:18,160 --> 00:43:21,100
make-vector's going to
take two coordinates,

780
00:43:21,100 --> 00:43:24,050
and here we can implement
them if we like as pairs,

781
00:43:24,050 --> 00:43:27,120
but the important thing is
that there's a constructor.

782
00:43:27,120 --> 00:43:31,890
And then given some vector, p,
we can find its x-coordinate,

783
00:43:31,890 --> 00:43:33,540
or we can get its y-coordinate.

784
00:43:33,540 --> 00:43:36,170
So there's a constructor
and selectors

785
00:43:36,170 --> 00:43:39,010
for points in the plane.

786
00:43:39,010 --> 00:43:40,670
Well, given points
in the plane, we

787
00:43:40,670 --> 00:43:42,420
might want to use them
to build something.

788
00:43:42,420 --> 00:43:44,020
So for instance, we
might want to talk

789
00:43:44,020 --> 00:43:48,460
about, we might have a
point, p, and a point, q,

790
00:43:48,460 --> 00:43:54,790
and p might be the point 1, 2,
and q might be the point 2, 3.

791
00:43:54,790 --> 00:43:58,970
And we might want to talk
about the line segment that

792
00:43:58,970 --> 00:44:01,570
starts at p and ends at q.

793
00:44:01,570 --> 00:44:05,180
And that might be the segment s.

794
00:44:05,180 --> 00:44:11,920
So we might want to
build points for vectors

795
00:44:11,920 --> 00:44:16,410
in terms of numbers, and
segments in terms of vectors.

796
00:44:16,410 --> 00:44:18,180
So we can represent
line segments

797
00:44:18,180 --> 00:44:19,920
in exactly the same way.

798
00:44:19,920 --> 00:44:21,724
All right, so the line
segment from p to q,

799
00:44:21,724 --> 00:44:23,640
we'll say there's a
constructor, make-segment.

800
00:44:23,640 --> 00:44:27,010


801
00:44:27,010 --> 00:44:29,530
And make up names
for the selectors,

802
00:44:29,530 --> 00:44:31,060
the starting point
of the segment

803
00:44:31,060 --> 00:44:32,560
and the ending point
of the segment.

804
00:44:32,560 --> 00:44:34,755
And again, we can implement
a segment using cons

805
00:44:34,755 --> 00:44:38,874
as a pair of points, and car
and cdr get out the two points

806
00:44:38,874 --> 00:44:40,540
that we put together
to get the segment.

807
00:44:40,540 --> 00:44:44,820


808
00:44:44,820 --> 00:44:48,210
Well, now having
done that, we can

809
00:44:48,210 --> 00:44:51,920
have some operations on them.

810
00:44:51,920 --> 00:44:57,610
Like we could say, what's the
midpoint of a line segment?

811
00:44:57,610 --> 00:45:00,140
So here's the midpoint
of a line segment,

812
00:45:00,140 --> 00:45:05,000
that's going to be the
points whose coordinates are

813
00:45:05,000 --> 00:45:07,310
the averages of the
coordinates of the endpoints.

814
00:45:07,310 --> 00:45:10,170
OK, there's the midpoint.

815
00:45:10,170 --> 00:45:12,060
So to get the midpoint
of a line segment,

816
00:45:12,060 --> 00:45:17,630
s, we'll just say grab the
starting point to the segment,

817
00:45:17,630 --> 00:45:20,320
grab the ending
point of the segment,

818
00:45:20,320 --> 00:45:24,500
and now make a vector-- make
a point whose coordinates are

819
00:45:24,500 --> 00:45:27,880
the average of the
x-coordinate of the first point

820
00:45:27,880 --> 00:45:30,220
and the x-coordinate
of the second point,

821
00:45:30,220 --> 00:45:33,530
and whose y-coordinate is the
average of the y-coordinates.

822
00:45:33,530 --> 00:45:37,810
So there's an
implementation of midpoint.

823
00:45:37,810 --> 00:45:42,130
And then similarly,
we can build something

824
00:45:42,130 --> 00:45:44,450
like the length of the segment.

825
00:45:44,450 --> 00:45:46,710
The length of the
segment is a thing

826
00:45:46,710 --> 00:45:52,850
whose-- use Pythagoras's rule,
the length of the segment

827
00:45:52,850 --> 00:45:57,100
is the square root of the d
x squared plus d y squared.

828
00:45:57,100 --> 00:46:00,600
We'll say to get the
length of a line segment,

829
00:46:00,600 --> 00:46:06,570
we'll let dx be the difference
of the x-coordinate of one

830
00:46:06,570 --> 00:46:11,560
endpoint and the x-coordinate
of the other endpoint,

831
00:46:11,560 --> 00:46:13,910
and we'll let dy
be the difference

832
00:46:13,910 --> 00:46:16,260
of the y-coordinates.

833
00:46:16,260 --> 00:46:17,860
And then we'll take
the square root

834
00:46:17,860 --> 00:46:22,251
of the sum of the squares of dx
and dy, that's what this says.

835
00:46:22,251 --> 00:46:26,190
All right, so there's an
implementation of length.

836
00:46:26,190 --> 00:46:35,760
And again, what we built
is a layered system.

837
00:46:35,760 --> 00:46:39,712
We built a system which
has, well, say up here

838
00:46:39,712 --> 00:46:40,420
there's segments.

839
00:46:40,420 --> 00:46:47,430


840
00:46:47,430 --> 00:46:50,530
And then there's an
abstraction barrier.

841
00:46:50,530 --> 00:46:56,880
The abstraction barrier
separates the implementation

842
00:46:56,880 --> 00:46:58,870
of segments from the
implementation of vectors

843
00:46:58,870 --> 00:47:02,460
and points, and what that
abstraction barrier is

844
00:47:02,460 --> 00:47:04,260
are the constructors
and selectors.

845
00:47:04,260 --> 00:47:14,750
It's make-segment, and
segment-start, and segment-end.

846
00:47:14,750 --> 00:47:18,030


847
00:47:18,030 --> 00:47:20,120
And then there are vectors.

848
00:47:20,120 --> 00:47:25,600
And vectors in turn are built
on top of pairs and numbers.

849
00:47:25,600 --> 00:47:29,670
So I'll say pairs and numbers.

850
00:47:29,670 --> 00:47:32,930
And that has its own
abstraction barrier,

851
00:47:32,930 --> 00:47:42,350
which is make-vector, and
x-coordinate, and y-coordinate.

852
00:47:42,350 --> 00:47:46,920


853
00:47:46,920 --> 00:47:48,930
So we have, again,
a layered system.

854
00:47:48,930 --> 00:47:52,080
You're starting to see
that there are layers here.

855
00:47:52,080 --> 00:47:57,470
I ought to mention, there
is a very important thing

856
00:47:57,470 --> 00:47:59,220
that I kind of took for granted.

857
00:47:59,220 --> 00:48:02,016


858
00:48:02,016 --> 00:48:04,670
And it's sort of so natural,
but on the other hand

859
00:48:04,670 --> 00:48:07,580
it's a very important thing.

860
00:48:07,580 --> 00:48:10,230
Notice that in order to
represent this segment

861
00:48:10,230 --> 00:48:16,600
s, I said this segment
is a pair of points.

862
00:48:16,600 --> 00:48:19,120
And a point is a
pair of numbers.

863
00:48:19,120 --> 00:48:21,750
And if I were going to
draw the box and pointers

864
00:48:21,750 --> 00:48:25,080
structure for that, I
would say, oh, the segment

865
00:48:25,080 --> 00:48:29,560
is, given those particular
representations that I showed

866
00:48:29,560 --> 00:48:34,050
you, I'd say this
segment s is a pair,

867
00:48:34,050 --> 00:48:40,600
and the first thing in
the pair is a vector,

868
00:48:40,600 --> 00:48:45,430
and the vector is
a pair of numbers.

869
00:48:45,430 --> 00:48:47,000
And that's this, that's p.

870
00:48:47,000 --> 00:48:50,190


871
00:48:50,190 --> 00:48:52,060
And the other thing
in the segment

872
00:48:52,060 --> 00:49:00,100
is q, which is itself
a pair of numbers.

873
00:49:00,100 --> 00:49:01,660
So I almost took
it for granted when

874
00:49:01,660 --> 00:49:08,960
I said that cons allows
you to put things together.

875
00:49:08,960 --> 00:49:12,420
But it's very easy
to not appreciate

876
00:49:12,420 --> 00:49:17,490
that, because notice, some of
the things I can put together

877
00:49:17,490 --> 00:49:20,720
can themselves be pairs.

878
00:49:20,720 --> 00:49:24,400
And let me introduce a word that
I'll talk about more next time,

879
00:49:24,400 --> 00:49:26,915
it's one of my favorite
words, called closure.

880
00:49:26,915 --> 00:49:30,640


881
00:49:30,640 --> 00:49:34,780
And by closure I mean that
the means of combination

882
00:49:34,780 --> 00:49:39,040
in your system are such that
when you put things together

883
00:49:39,040 --> 00:49:43,430
using them, like we make a pair,
you can then put those together

884
00:49:43,430 --> 00:49:45,080
with the same means
of combination.

885
00:49:45,080 --> 00:49:47,370
So I can have not only
a pair of numbers,

886
00:49:47,370 --> 00:49:48,675
but I can have a pair of pairs.

887
00:49:48,675 --> 00:49:51,710


888
00:49:51,710 --> 00:49:57,920
So for instance, making arrays
in a language like Fortran

889
00:49:57,920 --> 00:49:59,690
is not a closed
means of combination,

890
00:49:59,690 --> 00:50:01,575
because I can make
an array of numbers,

891
00:50:01,575 --> 00:50:03,100
but I can't make
an array of arrays.

892
00:50:03,100 --> 00:50:05,790


893
00:50:05,790 --> 00:50:09,060
And one of the things that you
should ask, one of your tests

894
00:50:09,060 --> 00:50:11,770
of quality for a
means of combination

895
00:50:11,770 --> 00:50:14,940
that someone shows
you, is gee, are

896
00:50:14,940 --> 00:50:18,340
the things you make closed
under that means of combination?

897
00:50:18,340 --> 00:50:21,460
So pairs would not be nearly so
interesting if all I could do

898
00:50:21,460 --> 00:50:23,160
was make a pair of numbers.

899
00:50:23,160 --> 00:50:26,754
I couldn't build very
much structure at all.

900
00:50:26,754 --> 00:50:28,170
OK, well, we'll
come back to that.

901
00:50:28,170 --> 00:50:29,503
I just wanted to mention it now.

902
00:50:29,503 --> 00:50:32,170
You'll hear a lot
about closure later on.

903
00:50:32,170 --> 00:50:38,420
You can also see the
potential for losing control

904
00:50:38,420 --> 00:50:40,970
of complexity as you have
a layered system if you

905
00:50:40,970 --> 00:50:44,030
don't use data abstraction.

906
00:50:44,030 --> 00:50:48,130
Let's go back and look
at this slide for length.

907
00:50:48,130 --> 00:50:52,826
Length works and is a simple
thing because I can say,

908
00:50:52,826 --> 00:50:55,510
when I want to get this
value, I can say, oh,

909
00:50:55,510 --> 00:51:00,430
that is the x-coordinate of the
first endpoint of the segment.

910
00:51:00,430 --> 00:51:02,767


911
00:51:02,767 --> 00:51:04,850
And each of these things,
each of these selectors,

912
00:51:04,850 --> 00:51:09,190
x-coordinate and endpoint,
stand for a decision choice

913
00:51:09,190 --> 00:51:12,260
whose details I don't
have to look at.

914
00:51:12,260 --> 00:51:14,500
So I could perfectly
well, again, just

915
00:51:14,500 --> 00:51:16,270
like rational numbers
I did before, I

916
00:51:16,270 --> 00:51:18,400
could say, oh well,
gee, a segment really

917
00:51:18,400 --> 00:51:21,180
is a pair of pairs.

918
00:51:21,180 --> 00:51:24,810
And the x-coordinate of the
first endpoint or the segment

919
00:51:24,810 --> 00:51:27,330
really is the--
well, what is it?

920
00:51:27,330 --> 00:51:33,890
It's the car of the
car of the segment.

921
00:51:33,890 --> 00:51:37,500
So I could perfectly well
go and redefine length.

922
00:51:37,500 --> 00:51:48,614
I could say, define the
length of some segment s.

923
00:51:48,614 --> 00:51:50,420
And I could start
off writing something

924
00:51:50,420 --> 00:51:56,062
like, well, we'll let dx be--
well, what's it have to be?

925
00:51:56,062 --> 00:51:58,270
It's got to be the difference
of the two coordinates,

926
00:51:58,270 --> 00:52:00,740
so that's the difference
of, the first one is

927
00:52:00,740 --> 00:52:08,910
the car of the car
of s, subtracted

928
00:52:08,910 --> 00:52:14,040
from the first one, the car
of the other half of it,

929
00:52:14,040 --> 00:52:16,140
the cdr of s.

930
00:52:16,140 --> 00:52:21,530


931
00:52:21,530 --> 00:52:24,820
All right, and then
dy would be-- well,

932
00:52:24,820 --> 00:52:27,260
let's see, I'd get
the y-coordinate,

933
00:52:27,260 --> 00:52:33,850
so it'd be the difference
of the cdr of the car of s,

934
00:52:33,850 --> 00:52:41,385
and the cdr of the cdr
of s, sort of go on.

935
00:52:41,385 --> 00:52:44,210


936
00:52:44,210 --> 00:52:46,800
You can see that's
much harder to read

937
00:52:46,800 --> 00:52:48,270
than the program I had before.

938
00:52:48,270 --> 00:52:52,681
But worse than that, suppose
you'd gone and implemented

939
00:52:52,681 --> 00:52:53,180
length?

940
00:52:53,180 --> 00:52:56,854


941
00:52:56,854 --> 00:52:59,020
And then the next day,
George comes to you and says,

942
00:52:59,020 --> 00:53:01,030
I'm sorry, I changed my mind.

943
00:53:01,030 --> 00:53:04,945
I want to write points with
the x-coordinate first.

944
00:53:04,945 --> 00:53:06,570
So you come back you
stare at this code

945
00:53:06,570 --> 00:53:07,861
and say, oh gee, what was that?

946
00:53:07,861 --> 00:53:13,980
That was the car, so I
have to change this to cdr,

947
00:53:13,980 --> 00:53:20,770
and this is cdr, and
this now has to be car.

948
00:53:20,770 --> 00:53:23,685
And this has to be car.

949
00:53:23,685 --> 00:53:25,060
And you sort of
do that, and then

950
00:53:25,060 --> 00:53:26,726
the next day George
comes back and says,

951
00:53:26,726 --> 00:53:31,410
sorry, the guys
designing the display

952
00:53:31,410 --> 00:53:35,490
would like lines to be painted
in the opposite direction,

953
00:53:35,490 --> 00:53:37,630
so I have to write the
endpoint first in the order.

954
00:53:37,630 --> 00:53:40,088
And then you come back and you
stare at this code, and say,

955
00:53:40,088 --> 00:53:42,400
gee, what was it talking about?

956
00:53:42,400 --> 00:53:44,930
Oh yeah, well I've got to
change this one to cdr,

957
00:53:44,930 --> 00:53:49,746
and this one becomes
car, this one comes car,

958
00:53:49,746 --> 00:53:50,620
and this becomes cdr.

959
00:53:50,620 --> 00:53:53,340
And you go up and do that,
and then the next day, George

960
00:53:53,340 --> 00:53:54,670
comes back and says,
I'm sorry, what I really

961
00:53:54,670 --> 00:53:56,130
meant is that the
segments always

962
00:53:56,130 --> 00:53:59,616
have to be painted from
left to right on the screen.

963
00:53:59,616 --> 00:54:00,990
And then you sort
of, it's clear,

964
00:54:00,990 --> 00:54:03,610
you just go and punch George
in the mouth at that point.

965
00:54:03,610 --> 00:54:09,310
But you see, as soon as
we have a 10 layer system,

966
00:54:09,310 --> 00:54:11,820
you see how that complexity
immediately builds up

967
00:54:11,820 --> 00:54:13,750
to the point where even
something like this

968
00:54:13,750 --> 00:54:16,250
gets out of control.

969
00:54:16,250 --> 00:54:19,560
So again, the way we've
gotten out of that

970
00:54:19,560 --> 00:54:21,150
is we've named that spirit.

971
00:54:21,150 --> 00:54:25,770
We built a system where
there is a thing, which

972
00:54:25,770 --> 00:54:29,420
is the representation
choice for how you're

973
00:54:29,420 --> 00:54:31,570
going to talk about vectors.

974
00:54:31,570 --> 00:54:33,450
And choices about
that representation

975
00:54:33,450 --> 00:54:35,472
are localized right there.

976
00:54:35,472 --> 00:54:36,930
They don't have
their guts spilling

977
00:54:36,930 --> 00:54:38,930
over into things like how
you compute the length

978
00:54:38,930 --> 00:54:40,926
and how you compute
the midpoint.

979
00:54:40,926 --> 00:54:45,660
And that's the real
power of this system.

980
00:54:45,660 --> 00:54:48,500
OK, we're explicit
about them, so

981
00:54:48,500 --> 00:54:50,916
that we have control over them.

982
00:54:50,916 --> 00:54:51,884
All right, questions?

983
00:54:51,884 --> 00:54:53,550
AUDIENCE: What happens
in the case where

984
00:54:53,550 --> 00:54:56,660
you don't want to be treating
objects in terms of pairs?

985
00:54:56,660 --> 00:55:00,420
For instance, in
three-dimensional space,

986
00:55:00,420 --> 00:55:01,680
you'd have three coordinates.

987
00:55:01,680 --> 00:55:03,640
Or even in the case where you
have n-dimensional space, what

988
00:55:03,640 --> 00:55:04,180
happens?

989
00:55:04,180 --> 00:55:05,140
PROFESSOR: Right, OK.

990
00:55:05,140 --> 00:55:08,374
Well, this is a preview
of what I'll say tomorrow.

991
00:55:08,374 --> 00:55:14,640
But the point is, once
you have two things,

992
00:55:14,640 --> 00:55:16,871
you have as many
things as you want.

993
00:55:16,871 --> 00:55:17,370
All right?

994
00:55:17,370 --> 00:55:19,310
Because if I want to
make three things,

995
00:55:19,310 --> 00:55:25,880
I could start making things
like a pair whose first thing is

996
00:55:25,880 --> 00:55:31,370
1, and whose second thing
is another pair that,

997
00:55:31,370 --> 00:55:34,582
say, has 2 and 3 in it.

998
00:55:34,582 --> 00:55:35,760
And so on, a hundred things.

999
00:55:35,760 --> 00:55:37,550
I can nest them out of pairs.

1000
00:55:37,550 --> 00:55:40,076
I made a pretty arbitrary
decision about how to do it,

1001
00:55:40,076 --> 00:55:41,450
and you can
immediately see there

1002
00:55:41,450 --> 00:55:42,724
are lots of ways to do that.

1003
00:55:42,724 --> 00:55:44,390
What we'll start
talking about next time

1004
00:55:44,390 --> 00:55:47,600
are conventions for how
to do things like that.

1005
00:55:47,600 --> 00:55:49,600
But notice that what this
really depends on is I

1006
00:55:49,600 --> 00:55:51,950
can make pairs of pairs.

1007
00:55:51,950 --> 00:55:54,380
If all I could do was make
pairs of numbers, I'd be stuck.

1008
00:55:54,380 --> 00:56:07,140


1009
00:56:07,140 --> 00:56:09,236
OK.

1010
00:56:09,236 --> 00:56:11,960
Let's break.

1011
00:56:11,960 --> 00:56:55,580
[MUSIC PLAYING]

1012
00:56:55,580 --> 00:56:57,080
All right, well,
we've just gone off

1013
00:56:57,080 --> 00:57:03,575
and done a couple of simple
examples of data abstraction.

1014
00:57:03,575 --> 00:57:05,695
Now I want to do something
more complicated.

1015
00:57:05,695 --> 00:57:08,310
We're going to talk
about what it means.

1016
00:57:08,310 --> 00:57:11,390
And this will be harder,
because it's always

1017
00:57:11,390 --> 00:57:13,340
much harder in
computer programming

1018
00:57:13,340 --> 00:57:16,450
to talk about what something
means than to go off and do it.

1019
00:57:16,450 --> 00:57:22,070
But let's go back to
almost the very beginning.

1020
00:57:22,070 --> 00:57:25,800
Let's go back to the
point where I said,

1021
00:57:25,800 --> 00:57:32,370
we just assumed that there
were procedures, make-RAT,

1022
00:57:32,370 --> 00:57:38,480
and numer, and denom.

1023
00:57:38,480 --> 00:57:41,570
Let's go back to where we had
this, at the very beginning,

1024
00:57:41,570 --> 00:57:44,920
constructors and
selectors, and went off

1025
00:57:44,920 --> 00:57:47,210
and defined the rational
number arithmetic.

1026
00:57:47,210 --> 00:57:48,940
And remember, I
said at that point

1027
00:57:48,940 --> 00:57:51,990
we were sort of done,
except for George.

1028
00:57:51,990 --> 00:57:55,920
Well, what is it that we'd
actually done at that point?

1029
00:57:55,920 --> 00:57:59,420
What was it that was done?

1030
00:57:59,420 --> 00:58:01,470
Well, what I want
to say is, what

1031
00:58:01,470 --> 00:58:04,680
was done after we'd
implemented the operations

1032
00:58:04,680 --> 00:58:08,780
and terms of these, was that we
had defined a rational number

1033
00:58:08,780 --> 00:58:12,390
representation in
terms of abstract data.

1034
00:58:12,390 --> 00:58:17,946


1035
00:58:17,946 --> 00:58:21,090
What do I mean by abstract data?

1036
00:58:21,090 --> 00:58:25,610
Well, the idea is
that at that point,

1037
00:58:25,610 --> 00:58:28,870
when we had our
+RAT and our *RAT,

1038
00:58:28,870 --> 00:58:33,060
that any implementation of
make-RAT, and numerator,

1039
00:58:33,060 --> 00:58:38,000
and denominator that
George supplied us with,

1040
00:58:38,000 --> 00:58:40,990
could be the basis for a
rational number representation.

1041
00:58:40,990 --> 00:58:44,500
Like, it wasn't our concern
where you divided through

1042
00:58:44,500 --> 00:58:48,980
to get the greatest common
denominator, or any of that.

1043
00:58:48,980 --> 00:58:52,260
So the idea is
that what we built

1044
00:58:52,260 --> 00:58:54,560
is a rational arithmetic
system that would sit

1045
00:58:54,560 --> 00:58:57,140
on top of any representation.

1046
00:58:57,140 --> 00:58:59,930
What do I mean by
any representation?

1047
00:58:59,930 --> 00:59:02,732
I mean, certainly it can't
be the case that all I mean

1048
00:59:02,732 --> 00:59:04,440
is George can reach
in a bag and pull out

1049
00:59:04,440 --> 00:59:09,830
three arbitrary procedures
and say, well, fine,

1050
00:59:09,830 --> 00:59:11,960
now that's the implementation.

1051
00:59:11,960 --> 00:59:14,080
That can't be what I mean.

1052
00:59:14,080 --> 00:59:18,070
What I've got to
mean is that there's

1053
00:59:18,070 --> 00:59:21,940
some way of saying whether
three procedures are

1054
00:59:21,940 --> 00:59:25,510
going to be suitable as a
basis for rational number

1055
00:59:25,510 --> 00:59:26,690
representation.

1056
00:59:26,690 --> 00:59:29,250
If we think about
it, what suitable

1057
00:59:29,250 --> 00:59:32,210
might mean is if I have to
assume something like this,

1058
00:59:32,210 --> 00:59:39,230
I have to say that if
x is the result of say,

1059
00:59:39,230 --> 00:59:59,730
doing make-RAT of n and d,
then the numerator of x divided

1060
00:59:59,730 --> 01:00:09,680
by the denominator of
x is equal to n over d.

1061
01:00:09,680 --> 01:00:13,770
See, what that is is
that's George's contract.

1062
01:00:13,770 --> 01:00:16,520
What we mean by writing a
contract for rational numbers,

1063
01:00:16,520 --> 01:00:18,790
if you think about it,
this is the right thing.

1064
01:00:18,790 --> 01:00:21,510
And the two ones we
showed do the right thing.

1065
01:00:21,510 --> 01:00:25,369
See, if I'm taking out
greatest common divisors,

1066
01:00:25,369 --> 01:00:27,410
it doesn't matter whether
I take them out or not,

1067
01:00:27,410 --> 01:00:29,830
or the place where I take
them, because the idea is I'm

1068
01:00:29,830 --> 01:00:32,380
going to divide through.

1069
01:00:32,380 --> 01:00:33,930
But see, this is
George's contract.

1070
01:00:33,930 --> 01:00:35,720
So what we really
say to George is

1071
01:00:35,720 --> 01:00:39,410
your business is to
go off and find us

1072
01:00:39,410 --> 01:00:41,806
three procedures,
make-RAT, and numerator,

1073
01:00:41,806 --> 01:00:45,660
and denominator, that
fulfill this contract

1074
01:00:45,660 --> 01:00:46,870
for any choice of n and d.

1075
01:00:46,870 --> 01:00:50,390
And that's what we
mean by we can use that

1076
01:00:50,390 --> 01:00:54,540
as the basis for a rational
number representation.

1077
01:00:54,540 --> 01:00:57,130
And other than that, it
fulfills this contract.

1078
01:00:57,130 --> 01:00:59,292
We don't care how he does it.

1079
01:00:59,292 --> 01:01:00,410
It's not our business.

1080
01:01:00,410 --> 01:01:02,330
It's below the layer
of abstraction.

1081
01:01:02,330 --> 01:01:07,010


1082
01:01:07,010 --> 01:01:13,539
In fact, if we want to say, what
is a rational number really?

1083
01:01:13,539 --> 01:01:15,080
See, what's it
really, without having

1084
01:01:15,080 --> 01:01:17,480
to talk about going below the
layer of abstraction, what

1085
01:01:17,480 --> 01:01:21,150
we're forced into saying
is a rational number

1086
01:01:21,150 --> 01:01:27,870
really is sort of this
axiom, is three procedures,

1087
01:01:27,870 --> 01:01:29,630
make-RAT, numerator,
and denominator,

1088
01:01:29,630 --> 01:01:32,370
that satisfy this axiom.

1089
01:01:32,370 --> 01:01:34,640
In some sense,
abstractly, that's

1090
01:01:34,640 --> 01:01:37,080
what a rational
number is really.

1091
01:01:37,080 --> 01:01:41,490


1092
01:01:41,490 --> 01:01:43,864
That's sort of easy
words to listen to,

1093
01:01:43,864 --> 01:01:45,780
because what you have
in your head, of course,

1094
01:01:45,780 --> 01:01:47,880
is well, for all this
thing about saying

1095
01:01:47,880 --> 01:01:50,742
that's what a rational
number is really,

1096
01:01:50,742 --> 01:01:52,950
you actually just saw that
we built rational numbers.

1097
01:01:52,950 --> 01:01:58,830


1098
01:01:58,830 --> 01:02:03,350
See, what we really did is
we built rational numbers

1099
01:02:03,350 --> 01:02:04,230
on top of pairs.

1100
01:02:04,230 --> 01:02:08,680


1101
01:02:08,680 --> 01:02:10,680
So for all I'm
saying abstractly,

1102
01:02:10,680 --> 01:02:15,450
we can say a rational number
really is just this axiom.

1103
01:02:15,450 --> 01:02:17,030
You can listen to
that comfortably,

1104
01:02:17,030 --> 01:02:18,446
because you're
saying, well, yeah,

1105
01:02:18,446 --> 01:02:21,950
but really it's actually pairs,
and I'm just annoying you

1106
01:02:21,950 --> 01:02:24,820
by trying to be abstract.

1107
01:02:24,820 --> 01:02:28,970
Well, let me, as an
antidote for that,

1108
01:02:28,970 --> 01:02:32,474
let me do something that I think
is really going to terrify you.

1109
01:02:32,474 --> 01:02:33,890
I mean, it's really
going to bring

1110
01:02:33,890 --> 01:02:39,320
you face to face with the
sort of existential reality

1111
01:02:39,320 --> 01:02:41,490
of this abstraction that
we're talking about.

1112
01:02:41,490 --> 01:02:45,960
And what I'm going to talk
about is, what are pairs really?

1113
01:02:45,960 --> 01:02:48,545
See, what did I tell
you about pairs?

1114
01:02:48,545 --> 01:02:49,420
I tricked you, right?

1115
01:02:49,420 --> 01:02:51,520
I said that Lisp has
this primitive called

1116
01:02:51,520 --> 01:02:53,520
cons that builds pairs.

1117
01:02:53,520 --> 01:02:56,470
But what did I really
tell you about?

1118
01:02:56,470 --> 01:02:59,510
If you go back and said,
let's look on this slide,

1119
01:02:59,510 --> 01:03:02,570
all I really told
you about pairs

1120
01:03:02,570 --> 01:03:05,680
is that there happens to be
this property, these properties

1121
01:03:05,680 --> 01:03:07,510
of cons, car, and
cdr. And all I really

1122
01:03:07,510 --> 01:03:10,350
said about pairs is that
there's a thing called cons,

1123
01:03:10,350 --> 01:03:14,870
and a thing called car,
and a thing called cdr.

1124
01:03:14,870 --> 01:03:17,750
And it is the case that
if I build cons of x, y

1125
01:03:17,750 --> 01:03:20,710
and take car of it, I get x.

1126
01:03:20,710 --> 01:03:25,810
And if I build cons of x, y
and get cdr of it, I get y.

1127
01:03:25,810 --> 01:03:31,602
And even though I lulled you
into thinking that there's

1128
01:03:31,602 --> 01:03:34,060
something in Lisp that does
that, so you pretended you knew

1129
01:03:34,060 --> 01:03:36,330
what it was, in fact, I
didn't tell you any more

1130
01:03:36,330 --> 01:03:39,750
about pairs than this tells
you about rational numbers.

1131
01:03:39,750 --> 01:03:41,050
It's just some axiom for pairs.

1132
01:03:41,050 --> 01:03:44,720


1133
01:03:44,720 --> 01:03:49,060
Well, to drive that
home, let me really

1134
01:03:49,060 --> 01:03:56,120
scare you, and show you what we
might build pairs in terms of.

1135
01:03:56,120 --> 01:03:58,280
And what you're going
to see is that we

1136
01:03:58,280 --> 01:04:01,890
can build rational
numbers, and line segments,

1137
01:04:01,890 --> 01:04:04,780
and vectors, and all of this
stuff in terms of pairs,

1138
01:04:04,780 --> 01:04:06,930
and we're going to see
below here that pairs can

1139
01:04:06,930 --> 01:04:10,680
be built out of nothing at all.

1140
01:04:10,680 --> 01:04:12,680
Pure abstraction.

1141
01:04:12,680 --> 01:04:17,620
So let me show you on this
slide an implementation

1142
01:04:17,620 --> 01:04:23,080
of cons, car, and cdr. And we'll
look at it again in a second,

1143
01:04:23,080 --> 01:04:26,880
but notice that their procedure
definitions of cons, car,

1144
01:04:26,880 --> 01:04:30,170
and cdr, you don't see any
data in there, what you see

1145
01:04:30,170 --> 01:04:34,720
is a lambda.

1146
01:04:34,720 --> 01:04:38,840
So cons here is
going to return--

1147
01:04:38,840 --> 01:04:41,660
is a procedure that
returns a procedure, just

1148
01:04:41,660 --> 01:04:44,630
like AVERAGE DAMP.

1149
01:04:44,630 --> 01:04:49,050
Cons of a and b returns a
procedure of an argument

1150
01:04:49,050 --> 01:04:54,825
called pick, and it says,
if pick is equal to 1,

1151
01:04:54,825 --> 01:04:58,940
I'm going to return a,
and if pick is equal to 2,

1152
01:04:58,940 --> 01:05:00,870
I'm going to return
b, and that's

1153
01:05:00,870 --> 01:05:02,000
what cons is going to be.

1154
01:05:02,000 --> 01:05:04,810


1155
01:05:04,810 --> 01:05:10,850
Car of a thing x,
car of a pair x,

1156
01:05:10,850 --> 01:05:12,304
is going to be x applied to 1.

1157
01:05:12,304 --> 01:05:13,470
And notice that makes sense.

1158
01:05:13,470 --> 01:05:16,690
You might not understand why
or how I'm doing such a thing,

1159
01:05:16,690 --> 01:05:19,820
but at least it makes sense,
because the thing constructed

1160
01:05:19,820 --> 01:05:24,630
by cons is a procedure,
and car applies that to 1.

1161
01:05:24,630 --> 01:05:29,370
And similarly, cdr
applies that thing to 2.

1162
01:05:29,370 --> 01:05:33,290
OK, now I claimed that this is
a representation of cons, car,

1163
01:05:33,290 --> 01:05:35,780
and cdr, and notice
there's no data in it.

1164
01:05:35,780 --> 01:05:37,190
All right, it's
built out of air.

1165
01:05:37,190 --> 01:05:39,600
It's just procedures.

1166
01:05:39,600 --> 01:05:43,640
There's no data objects at
all in that representation.

1167
01:05:43,640 --> 01:05:45,140
Well, what could
that possibly mean?

1168
01:05:45,140 --> 01:05:49,690


1169
01:05:49,690 --> 01:05:54,320
Well, if you really
believe this stuff,

1170
01:05:54,320 --> 01:05:57,060
then you have to
believe that in order

1171
01:05:57,060 --> 01:05:59,390
to show that that's a
representation for cons, car,

1172
01:05:59,390 --> 01:06:01,140
and cdr, all I
have to do is show

1173
01:06:01,140 --> 01:06:03,550
that it satisfies the axiom.

1174
01:06:03,550 --> 01:06:05,410
See, all I should have
to convince you of

1175
01:06:05,410 --> 01:06:22,310
is, for example, that gee,
that car of cons of 37 and 49

1176
01:06:22,310 --> 01:06:28,060
is 37 for arbitrary
values of 37 and 49.

1177
01:06:28,060 --> 01:06:29,070
And cdr the same way.

1178
01:06:29,070 --> 01:06:32,070


1179
01:06:32,070 --> 01:06:34,430
See, if I really can
demonstrate to you

1180
01:06:34,430 --> 01:06:37,430
that that weird procedure
definition, in terms

1181
01:06:37,430 --> 01:06:41,810
of [? air ?], has the property
that it satisfies this,

1182
01:06:41,810 --> 01:06:43,880
then you just have
to grant me that that

1183
01:06:43,880 --> 01:06:47,970
is a possible implementation of
cons, car, and cdr, on which I

1184
01:06:47,970 --> 01:06:49,939
can build everything else.

1185
01:06:49,939 --> 01:06:50,980
Well, let's look at that.

1186
01:06:50,980 --> 01:06:53,820
And this will be practice
in the substitution model.

1187
01:06:53,820 --> 01:06:59,320


1188
01:06:59,320 --> 01:07:00,549
How could we check this?

1189
01:07:00,549 --> 01:07:01,840
We sort of know how to do that.

1190
01:07:01,840 --> 01:07:05,811
It's just the same
substitution model.

1191
01:07:05,811 --> 01:07:06,310
Let's look.

1192
01:07:06,310 --> 01:07:11,120
We start out, and we say,
what's car of cons of 37 and 49?

1193
01:07:11,120 --> 01:07:11,720
What do we do?

1194
01:07:11,720 --> 01:07:13,085
Cons is some procedure.

1195
01:07:13,085 --> 01:07:15,950


1196
01:07:15,950 --> 01:07:19,530
Its value is cons was
a procedure of a and b.

1197
01:07:19,530 --> 01:07:23,440
The thing returned by
cons is its procedure body

1198
01:07:23,440 --> 01:07:27,370
with 37 and 49 substituted
for the parameters.

1199
01:07:27,370 --> 01:07:32,770
It'll be 37 substituted for
a and 49 substituted for b.

1200
01:07:32,770 --> 01:07:37,170
So this expression has the same
meaning as this expression.

1201
01:07:37,170 --> 01:07:40,270
Its car of, and the body
of cons was this thing

1202
01:07:40,270 --> 01:07:43,190
that started with lambda.

1203
01:07:43,190 --> 01:07:46,090
And it says, so if
pick is equal to 1,

1204
01:07:46,090 --> 01:07:47,630
where pick is this
other argument,

1205
01:07:47,630 --> 01:07:51,450
if pick is equal to 1, it's
37, that's where a was,

1206
01:07:51,450 --> 01:07:55,240
and if pick is
equal to 2, it's 49.

1207
01:07:55,240 --> 01:07:56,410
So that's the first step.

1208
01:07:56,410 --> 01:07:59,190
I'm just going through
mechanical substitution.

1209
01:07:59,190 --> 01:08:00,940
And remember, at this
point in the course,

1210
01:08:00,940 --> 01:08:02,690
if you're confused
about what things mean,

1211
01:08:02,690 --> 01:08:05,480
go mechanically through
the substitution model.

1212
01:08:05,480 --> 01:08:07,920
Well, what is this reduced to?

1213
01:08:07,920 --> 01:08:15,050
Car said, take your argument,
which in this case is this,

1214
01:08:15,050 --> 01:08:16,060
and apply it to 1.

1215
01:08:16,060 --> 01:08:17,979
That was the definition of car.

1216
01:08:17,979 --> 01:08:22,370
So if I look at car, if
I do that, the answer is,

1217
01:08:22,370 --> 01:08:25,165
well, it's that argument,
this was the argument to car,

1218
01:08:25,165 --> 01:08:26,319
applied to 1.

1219
01:08:26,319 --> 01:08:29,580


1220
01:08:29,580 --> 01:08:31,140
Well, what does that mean?

1221
01:08:31,140 --> 01:08:33,970
I take 1, and I
substitute it in the body

1222
01:08:33,970 --> 01:08:36,120
here for this value
of pick, which

1223
01:08:36,120 --> 01:08:39,779
is the name of the
argument, what do I get?

1224
01:08:39,779 --> 01:08:43,390
Well, I get the thing that
says if 1 equals 1 it's 37,

1225
01:08:43,390 --> 01:08:46,700
and if 1 equals 2 it's
49, so the answer's 37.

1226
01:08:46,700 --> 01:08:49,880
And similarly, if I'd taken
cdr, that would apply it to 2,

1227
01:08:49,880 --> 01:08:51,729
and I'd get 49.

1228
01:08:51,729 --> 01:08:53,810
So you see, what
I've demonstrated

1229
01:08:53,810 --> 01:08:57,560
is that that completely weird
implementation of cons, car,

1230
01:08:57,560 --> 01:09:00,120
and cdr, satisfies the axioms.

1231
01:09:00,120 --> 01:09:02,640
So it's a perfectly
valid way of building,

1232
01:09:02,640 --> 01:09:05,417
in fact, all of the data objects
we're going to see in Lisp.

1233
01:09:05,417 --> 01:09:07,000
So they all, if you
like, can be built

1234
01:09:07,000 --> 01:09:09,670
on sort of existential nothing.

1235
01:09:09,670 --> 01:09:14,229
And as far as you know,
that's how it works.

1236
01:09:14,229 --> 01:09:15,149
You couldn't tell.

1237
01:09:15,149 --> 01:09:17,856
If all you're ever
going to do with pairs

1238
01:09:17,856 --> 01:09:20,439
is construct them with cons and
look at them with car and cdr,

1239
01:09:20,439 --> 01:09:23,946
you couldn't possibly
tell how this thing works.

1240
01:09:23,946 --> 01:09:26,529
Now, it might give you a sort
of warm feeling inside if I say,

1241
01:09:26,529 --> 01:09:29,470
well, yeah, in fact, for
various reasons there happens

1242
01:09:29,470 --> 01:09:31,770
to be a primitive called
cons, car, and cdr,

1243
01:09:31,770 --> 01:09:34,950
and if it's too scary, if this
kind of stuff is too scary,

1244
01:09:34,950 --> 01:09:36,770
you don't have to
look inside of it.

1245
01:09:36,770 --> 01:09:39,069
So that might make
you feel better,

1246
01:09:39,069 --> 01:09:41,792
but the point is, it
really could work this way,

1247
01:09:41,792 --> 01:09:43,250
and it wouldn't
make any difference

1248
01:09:43,250 --> 01:09:46,590
to the system at all.

1249
01:09:46,590 --> 01:09:48,640
So in some sense, we
don't need data at all

1250
01:09:48,640 --> 01:09:51,760
to build these
data abstractions.

1251
01:09:51,760 --> 01:09:54,860
We can do everything
in terms of procedures.

1252
01:09:54,860 --> 01:09:57,500
OK, well, why did I
terrify you in this way?

1253
01:09:57,500 --> 01:09:59,130
First, I really
want to reinforce

1254
01:09:59,130 --> 01:10:02,800
this idea of abstraction,
that you really

1255
01:10:02,800 --> 01:10:06,220
can do these things abstractly.

1256
01:10:06,220 --> 01:10:10,200
Secondly, I want to
introduce an idea

1257
01:10:10,200 --> 01:10:14,430
we're going to see more and
more of in this course, which

1258
01:10:14,430 --> 01:10:17,440
is we're going to blur the
line between what's data

1259
01:10:17,440 --> 01:10:19,715
and what's a procedure.

1260
01:10:19,715 --> 01:10:21,840
See, in this funny
implementation

1261
01:10:21,840 --> 01:10:25,060
it turned out that
cons of something

1262
01:10:25,060 --> 01:10:27,320
happened to be represented
in terms of a procedure,

1263
01:10:27,320 --> 01:10:29,080
even though we
think of it as data.

1264
01:10:29,080 --> 01:10:31,940


1265
01:10:31,940 --> 01:10:34,630
While here that's sort
of a mathematical trick,

1266
01:10:34,630 --> 01:10:36,350
but one of the
things we'll see is

1267
01:10:36,350 --> 01:10:38,540
that a lot of the very
important programming

1268
01:10:38,540 --> 01:10:42,150
techniques that we're
going to get to sort of

1269
01:10:42,150 --> 01:10:44,400
depend very
crucially on blurring

1270
01:10:44,400 --> 01:10:47,580
this traditional line between
what you consider a procedure

1271
01:10:47,580 --> 01:10:48,950
and what you consider data.

1272
01:10:48,950 --> 01:10:52,495
We're going to see more and more
of that, especially next time.

1273
01:10:52,495 --> 01:10:55,190
OK, questions?

1274
01:10:55,190 --> 01:10:56,770
AUDIENCE: If you
asked the system

1275
01:10:56,770 --> 01:11:00,720
to print a, what would happen?

1276
01:11:00,720 --> 01:11:04,390
PROFESSOR: The question
is, what would happen if I

1277
01:11:04,390 --> 01:11:05,600
asked the system to print a.

1278
01:11:05,600 --> 01:11:10,200
Given this representation,
you already know the answer.

1279
01:11:10,200 --> 01:11:18,485
The answer is compound procedure
a, just like last time.

1280
01:11:18,485 --> 01:11:21,170


1281
01:11:21,170 --> 01:11:22,590
It'd say compound procedure.

1282
01:11:22,590 --> 01:11:25,129


1283
01:11:25,129 --> 01:11:26,420
It might say a little bit more.

1284
01:11:26,420 --> 01:11:29,620
It might say compound procedure
lambda or something or other,

1285
01:11:29,620 --> 01:11:31,730
depending on details
of how I named it.

1286
01:11:31,730 --> 01:11:33,070
But it's a procedure.

1287
01:11:33,070 --> 01:11:34,890
And the only reason
for that is I

1288
01:11:34,890 --> 01:11:37,620
haven't told the
system anything special

1289
01:11:37,620 --> 01:11:40,220
about how to print such things.

1290
01:11:40,220 --> 01:11:43,500
Now, it's in fact true that
with the actual implementation

1291
01:11:43,500 --> 01:11:45,270
of cons that to be
built in the system,

1292
01:11:45,270 --> 01:11:46,840
it would print something else.

1293
01:11:46,840 --> 01:11:48,890
It would print,
say, this is a pair.

1294
01:11:48,890 --> 01:11:53,500


1295
01:11:53,500 --> 01:11:58,410
AUDIENCE: When you
define cons, and then you

1296
01:11:58,410 --> 01:12:01,840
pass it into values,
how does it know

1297
01:12:01,840 --> 01:12:05,700
where to look for the cons,
because you can use cons

1298
01:12:05,700 --> 01:12:07,220
over and over again?

1299
01:12:07,220 --> 01:12:11,285
How does it know where to
look to know which a and b

1300
01:12:11,285 --> 01:12:13,500
it's supposed to pull back out?

1301
01:12:13,500 --> 01:12:17,140
I don't know if I'm
expressing that quite right.

1302
01:12:17,140 --> 01:12:19,120
Where is it stored?

1303
01:12:19,120 --> 01:12:23,660
PROFESSOR: OK, the
question is, I sort of have

1304
01:12:23,660 --> 01:12:27,370
a cons with a 37 and a 49,
and I might make another cons

1305
01:12:27,370 --> 01:12:29,766
with a 1 and a 2, and I
might have one called a,

1306
01:12:29,766 --> 01:12:31,817
and I might have one called b.

1307
01:12:31,817 --> 01:12:33,400
And the question is,
how does it know?

1308
01:12:33,400 --> 01:12:35,275
And why don't they get confused?

1309
01:12:35,275 --> 01:12:37,510
And that's a very good question.

1310
01:12:37,510 --> 01:12:40,820


1311
01:12:40,820 --> 01:12:43,410
See, you have to really
believe that the procedures are

1312
01:12:43,410 --> 01:12:45,550
objects.

1313
01:12:45,550 --> 01:12:49,340
It's sort of like saying-- let's
try another simpler example.

1314
01:12:49,340 --> 01:12:51,190
Suppose I ask for
the square root of 3.

1315
01:12:51,190 --> 01:12:55,760


1316
01:12:55,760 --> 01:12:58,260
So I asked for the
square root of 5,

1317
01:12:58,260 --> 01:13:00,826
and then I ask for
the square of 20.

1318
01:13:00,826 --> 01:13:06,216


1319
01:13:06,216 --> 01:13:07,590
You're probably
not the least bit

1320
01:13:07,590 --> 01:13:10,480
bothered that I can take
square root and apply it to 5,

1321
01:13:10,480 --> 01:13:14,624
and then I can take square
root and apply it to 20.

1322
01:13:14,624 --> 01:13:16,040
And there's sort
of no issue, gee,

1323
01:13:16,040 --> 01:13:17,790
doesn't it get confused
about whether it's

1324
01:13:17,790 --> 01:13:19,630
working on 5 or 20?

1325
01:13:19,630 --> 01:13:22,630
There's no issue about
that because you're

1326
01:13:22,630 --> 01:13:26,600
thinking of a procedure which
goes off and does something.

1327
01:13:26,600 --> 01:13:30,410
Now, in some sense you're
asking me the same question.

1328
01:13:30,410 --> 01:13:32,750
But it's really bothering
you, and it's bothering you

1329
01:13:32,750 --> 01:13:34,140
for a really good reason.

1330
01:13:34,140 --> 01:13:36,990
Because when I write that,
you're saying gee, this is,

1331
01:13:36,990 --> 01:13:38,300
I know, sort of a procedure.

1332
01:13:38,300 --> 01:13:40,250
But it's not a procedure
that's just running.

1333
01:13:40,250 --> 01:13:42,600
It's just sort of a
procedure sitting there.

1334
01:13:42,600 --> 01:13:46,960
And how can it be that sometimes
this procedure has 37 and 49,

1335
01:13:46,960 --> 01:13:49,740
and there might be another one
which has 5 and 6 in there,

1336
01:13:49,740 --> 01:13:52,630
and why don't they get confused?

1337
01:13:52,630 --> 01:13:58,990
So there's something very, very
important that's bothering you.

1338
01:13:58,990 --> 01:14:01,380
And it's really crucial
to what's going on.

1339
01:14:01,380 --> 01:14:06,280
We're suddenly saying that
procedures are not just the act

1340
01:14:06,280 --> 01:14:08,290
of doing something.

1341
01:14:08,290 --> 01:14:11,940
Procedures are conceptual
entities, objects,

1342
01:14:11,940 --> 01:14:14,910
and if I built
cons of 37 and 49,

1343
01:14:14,910 --> 01:14:18,070
that's a particular
procedure that sits there.

1344
01:14:18,070 --> 01:14:21,312
And it's different
from cons of 3 and 4.

1345
01:14:21,312 --> 01:14:23,020
That's another procedure
that sits there.

1346
01:14:23,020 --> 01:14:24,060
AUDIENCE: Both of them
exist independently.

1347
01:14:24,060 --> 01:14:25,610
PROFESSOR: And
exists independently.

1348
01:14:25,610 --> 01:14:28,370
AUDIENCE: And they both can
be referenced by car and cdr.

1349
01:14:28,370 --> 01:14:30,870
PROFESSOR: And they both would
be referenced by car and cdr.

1350
01:14:30,870 --> 01:14:35,290
Just like I could
increment this,

1351
01:14:35,290 --> 01:14:38,270
and I could increment that.

1352
01:14:38,270 --> 01:14:39,960
They're objects.

1353
01:14:39,960 --> 01:14:41,730
And that's sort of
where we're going.

1354
01:14:41,730 --> 01:14:43,280
See, the fact that you're
asking the question

1355
01:14:43,280 --> 01:14:44,654
shows that you're
really starting

1356
01:14:44,654 --> 01:14:47,790
to think about the implications
of what's going on.

1357
01:14:47,790 --> 01:14:50,700
It's the difference between
saying a procedure is just

1358
01:14:50,700 --> 01:14:53,070
the act of doing something.

1359
01:14:53,070 --> 01:14:56,270
And a procedure is a real
object that has existence.

1360
01:14:56,270 --> 01:14:58,377
AUDIENCE: So when the
procedure gets built,

1361
01:14:58,377 --> 01:15:01,050
the actual values are now
substituted for a and b--

1362
01:15:01,050 --> 01:15:02,050
PROFESSOR: That's right.

1363
01:15:02,050 --> 01:15:04,870
AUDIENCE: And then that
procedure exists as lambda,

1364
01:15:04,870 --> 01:15:07,720
and pick is what's
actually passed in.

1365
01:15:07,720 --> 01:15:11,850
PROFESSOR: Yes, when cons gets
called, and the result of cons

1366
01:15:11,850 --> 01:15:13,530
is a new procedure
that's constructed,

1367
01:15:13,530 --> 01:15:17,080
that new procedure has an
argument that's called pick.

1368
01:15:17,080 --> 01:15:18,830
AUDIENCE: But it no
longer has an a and b.

1369
01:15:18,830 --> 01:15:20,820
The a and b are the actual
values that are passed through.

1370
01:15:20,820 --> 01:15:23,320
PROFESSOR: And it has-- right,
according to the substitution

1371
01:15:23,320 --> 01:15:26,340
model, what it now has is not
those arbitrary names a and b,

1372
01:15:26,340 --> 01:15:31,187
it somehow has that
37 and 49 in there.

1373
01:15:31,187 --> 01:15:33,520
But you're right, that's a
hard thing to think about it,

1374
01:15:33,520 --> 01:15:35,103
and it's different
from the way you've

1375
01:15:35,103 --> 01:15:36,500
been thinking about procedures.

1376
01:15:36,500 --> 01:15:38,975
AUDIENCE: And if I have
again cons of 37 and 49,

1377
01:15:38,975 --> 01:15:41,300
it's a different object?

1378
01:15:41,300 --> 01:15:51,790
PROFESSOR: And if you make
another cons of 37 and 49,

1379
01:15:51,790 --> 01:15:54,390
you're into a wonderful
philosophical problem, which

1380
01:15:54,390 --> 01:15:57,730
is going to be what the
lecture about halfway

1381
01:15:57,730 --> 01:16:00,080
through this course is about.

1382
01:16:00,080 --> 01:16:03,340
Which is, if I cons 37
and 49, and I do it again,

1383
01:16:03,340 --> 01:16:06,490
is that the same thing, or
is it a different thing?

1384
01:16:06,490 --> 01:16:07,680
And how could you tell?

1385
01:16:07,680 --> 01:16:10,240
And when could it
possibly matter?

1386
01:16:10,240 --> 01:16:21,140
And that's sort of like saying,
is that the same thing as this?

1387
01:16:21,140 --> 01:16:23,850
Or is this the
same thing as that?

1388
01:16:23,850 --> 01:16:25,150
It's the same kind of question.

1389
01:16:25,150 --> 01:16:27,930
And that's a very,
very deep question.

1390
01:16:27,930 --> 01:16:30,180
And I can't answer
in less than an hour.

1391
01:16:30,180 --> 01:16:31,770
But we will.

1392
01:16:31,770 --> 01:16:45,972